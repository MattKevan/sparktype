import type { PublishingProvider, PublishingResult, ValidationResult, PublishingConfigSchema } from './types';
import type { LocalSiteData } from '@/core/types';

export abstract class BaseProvider implements PublishingProvider {
  abstract readonly name: string;
  abstract readonly displayName: string;

  abstract deploy(site: LocalSiteData, config: Record<string, unknown>): Promise<PublishingResult>;
  abstract validateConfig(config: Record<string, unknown>): Promise<ValidationResult>;
  abstract getConfigSchema(): PublishingConfigSchema;

  /**
   * Generate static site files from the site data
   */
  protected async generateSiteFiles(site: LocalSiteData): Promise<Map<string, string | Uint8Array>> {
    // TODO: Implement site generation logic
    // This would convert the LocalSiteData into actual HTML/CSS/JS files
    const files = new Map<string, string | Uint8Array>();
    
    // For now, create a basic index.html
    const indexHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${site.manifest.title || 'Untitled Site'}</title>
</head>
<body>
    <h1>${site.manifest.title || 'Untitled Site'}</h1>
    <p>${site.manifest.description || 'No description provided.'}</p>
    <p><em>Generated by Sparktype</em></p>
</body>
</html>`.trim();

    files.set('index.html', indexHtml);
    
    return files;
  }

  /**
   * Validate required configuration fields
   */
  protected validateRequiredFields(config: Record<string, unknown>, requiredFields: string[]): ValidationResult {
    const errors: string[] = [];
    
    for (const field of requiredFields) {
      if (!config[field] || (typeof config[field] === 'string' && config[field].trim() === '')) {
        errors.push(`${field} is required`);
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
}