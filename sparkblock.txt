FILE CONCATENATION REPORT
Root Directory: src/packages/sparkblock/
Excluded Directories: public, ios, node_modules
File Extensions: *.ts, *.tsx, *.js, *.jsx, *.css, *.html, *.json, *.hbs
================================================================================

File: errors.ts
// src/packages/sparkblock/errors.ts

import type { ValidationResult } from './types';

export class SparkBlockError extends Error {
  constructor(
    message: string,
    public code?: string,
    public blockId?: string
  ) {
    super(message);
    this.name = 'SparkBlockError';
  }
}

export class SparkBlockValidationError extends SparkBlockError {
  constructor(
    message: string,
    public validation: ValidationResult,
    blockId?: string
  ) {
    super(message, 'VALIDATION_ERROR', blockId);
    this.name = 'SparkBlockValidationError';
  }
}

export class SparkBlockAdapterError extends SparkBlockError {
  constructor(message: string, public originalError?: Error) {
    super(message, 'ADAPTER_ERROR');
    this.name = 'SparkBlockAdapterError';
  }
}

================================================================================

File: index.ts
// src/packages/sparkblock/index.ts

// === CORE TYPES ===
export type {
  SparkBlock,
  BlockDefinition,
  BlockField,
  BlockRegion,
  BlockTrigger,
  BlockBehavior,
  BlockShortcut,
  ValidationResult,
  ValidationError,
  ValidationWarning,
  InsertPosition,
  MoveOperation,
  UpdateOperation,
  SparkBlockAdapter,
  RenderContext,
  SparkBlockTheme,
  SparkBlockPlugin,
  SparkBlockCommand,
  SparkBlockEngine,
  SparkBlockEngineOptions,
  SparkBlockEngineState,
  SparkBlockEvent,
  SparkBlockEventListener
} from './types';

// === ENGINE ===
export { createSparkBlockEngine } from './engine/SparkBlockEngine';
export type { SparkBlockEngineImpl } from './engine/SparkBlockEngine';

// === UTILITIES ===
export { BlockOperations, BlockQueries } from './utils/blockOperations';
export type { BlockPath, BlockLocation } from './utils/blockOperations';

// === REACT COMPONENTS ===
export { SparkBlockEditor } from './components/SparkBlockEditor';
export { SparkBlockProvider, useSparkBlock } from './components/SparkBlockProvider';
export { BlockCanvas } from './components/BlockCanvas';
export { BlockRenderer } from './components/BlockRenderer';
export { BlockToolbar } from './components/BlockToolbar';
export { PlusMenu } from './components/PlusMenu';
export { BlockMenu } from './components/BlockMenu';
export { FloatingToolbar } from './components/FloatingToolbar';

// === DEFAULT BLOCK RENDERERS ===
export { DefaultBlockRenderers } from './components/blocks/DefaultBlockRenderers';
export type { BlockComponentProps } from './components/blocks/DefaultBlockRenderers';

// === ERROR TYPES ===
export {
  SparkBlockError,
  SparkBlockValidationError,
  SparkBlockAdapterError
} from './types';

// === DEFAULT THEME ===
export const DEFAULT_SPARKBLOCK_THEME: SparkBlockTheme = {
  name: 'default',
  colors: {
    background: '#ffffff',
    foreground: '#1a1a1a',
    primary: '#0066cc',
    secondary: '#666666',
    muted: '#f5f5f5',
    accent: '#0052a3',
    border: '#e0e0e0',
    
    blockBackground: '#ffffff',
    blockBorder: '#e0e0e0',
    blockHover: '#f8f9fa',
    blockSelected: '#e3f2fd',
    blockFocused: '#1976d2'
  },
  
  spacing: {
    blockGap: '8px',
    inlineGap: '4px',
    padding: '12px',
    margin: '8px'
  },
  
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    fontSize: '14px',
    lineHeight: '1.5',
    
    heading1: { fontSize: '32px', fontWeight: '700', lineHeight: '1.2' },
    heading2: { fontSize: '24px', fontWeight: '600', lineHeight: '1.3' },
    heading3: { fontSize: '20px', fontWeight: '600', lineHeight: '1.4' },
    body: { fontSize: '14px', fontWeight: '400', lineHeight: '1.5' },
    code: { fontFamily: 'Monaco, Consolas, "Courier New", monospace', fontSize: '13px' }
  }
};

// === VERSION ===
export const SPARKBLOCK_VERSION = '1.0.0';

================================================================================

File: types/index.ts
// src/packages/sparkblock/types/index.ts

import type { ReactNode } from 'react';

// === CORE BLOCK TYPES ===

export interface SparkBlock<TContent = Record<string, unknown>> {
  id: string;
  type: string;
  content: TContent;
  config?: Record<string, unknown>;
  regions?: Record<string, SparkBlock[]>;
  metadata?: {
    createdAt?: number;
    updatedAt?: number;
    version?: number;
    [key: string]: unknown;
  };
}

export interface BlockDefinition {
  id: string;
  name: string;
  category: string;
  description?: string;
  icon?: ReactNode;
  keywords?: string[];
  
  // Field schema for the block content
  fields?: Record<string, BlockField>;
  
  // Region definitions for container blocks
  regions?: Record<string, BlockRegion>;
  
  // Auto-detection patterns
  triggers?: BlockTrigger[];
  
  // Behavior configuration
  behavior?: BlockBehavior;
  
  // Custom validation
  validate?: (block: SparkBlock) => ValidationResult;
}

export interface BlockField {
  type: 'text' | 'number' | 'boolean' | 'select' | 'array' | 'object' | 'image' | 'url';
  label: string;
  required?: boolean;
  default?: unknown;
  placeholder?: string;
  options?: string[]; // for select fields
  validation?: {
    min?: number;
    max?: number;
    pattern?: string;
    custom?: (value: unknown) => string | null;
  };
}

export interface BlockRegion {
  label: string;
  allowedBlocks?: string[]; // empty = all blocks allowed
  required?: boolean;
  maxItems?: number;
  minItems?: number;
}

export interface BlockTrigger {
  pattern: string | RegExp;
  confidence: number;
  cleanText?: (text: string) => string;
}

export interface BlockBehavior {
  insertable?: boolean;
  duplicatable?: boolean;
  deletable?: boolean;
  moveable?: boolean;
  splittable?: boolean;
  mergeable?: boolean;
  
  // Keyboard shortcuts
  shortcuts?: BlockShortcut[];
  
  // Auto-formatting
  autoFormat?: boolean;
}

export interface BlockShortcut {
  key: string;
  modifier?: 'ctrl' | 'cmd' | 'alt' | 'shift' | Array<'ctrl' | 'cmd' | 'alt' | 'shift'>;
  description?: string;
  action: string; // command name
}

// === VALIDATION ===

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings?: ValidationWarning[];
}

export interface ValidationError {
  field?: string;
  message: string;
  code?: string;
}

export interface ValidationWarning {
  field?: string;
  message: string;
  code?: string;
}

// === OPERATIONS ===

export interface InsertPosition {
  targetId?: string;
  position: 'before' | 'after' | 'inside';
  regionName?: string;
}

export interface MoveOperation {
  blockId: string;
  targetId?: string;
  position: 'before' | 'after' | 'inside';
  regionName?: string;
}

export interface UpdateOperation {
  blockId: string;
  content?: Partial<Record<string, unknown>>;
  config?: Partial<Record<string, unknown>>;
}

// === ADAPTER INTERFACE ===

export interface SparkBlockAdapter<TDocument = unknown> {
  // Document transformation
  parse(document: TDocument): Promise<SparkBlock[]>;
  serialize(blocks: SparkBlock[]): Promise<TDocument>;
  
  // Block registry
  getAvailableBlocks(): Promise<BlockDefinition[]>;
  getBlockDefinition(type: string): Promise<BlockDefinition | null>;
  createBlock(type: string, initialData?: Record<string, unknown>): Promise<SparkBlock>;
  validateBlock(block: SparkBlock): Promise<ValidationResult>;
  
  // Optional: Custom rendering
  renderBlock?(block: SparkBlock, context: RenderContext): ReactNode;
  
  // Optional: Custom commands
  executeCommand?(command: string, ...args: unknown[]): Promise<unknown>;
}

export interface RenderContext {
  isEditing: boolean;
  isSelected: boolean;
  isFocused: boolean;
  isDragging: boolean;
  nestingLevel: number;
  
  // Editor state
  readonly: boolean;
  theme?: SparkBlockTheme;
  
  // Callbacks
  onFocus?: (blockId: string) => void;
  onBlur?: (blockId: string) => void;
  onChange?: (blockId: string, content: Record<string, unknown>) => void;
  onKeyDown?: (blockId: string, event: React.KeyboardEvent) => void;
}

// === THEMING ===

export interface SparkBlockTheme {
  name: string;
  colors: {
    background: string;
    foreground: string;
    primary: string;
    secondary: string;
    muted: string;
    accent: string;
    border: string;
    
    // Block-specific
    blockBackground: string;
    blockBorder: string;
    blockHover: string;
    blockSelected: string;
    blockFocused: string;
  };
  
  spacing: {
    blockGap: string;
    inlineGap: string;
    padding: string;
    margin: string;
  };
  
  typography: {
    fontFamily: string;
    fontSize: string;
    lineHeight: string;
    
    // Block-specific typography
    heading1: { fontSize: string; fontWeight: string; lineHeight: string };
    heading2: { fontSize: string; fontWeight: string; lineHeight: string };
    heading3: { fontSize: string; fontWeight: string; lineHeight: string };
    body: { fontSize: string; fontWeight: string; lineHeight: string };
    code: { fontFamily: string; fontSize: string; };
  };
  
  // Component-specific styles
  components?: {
    plusButton?: Record<string, string>;
    dragHandle?: Record<string, string>;
    blockMenu?: Record<string, string>;
    toolbar?: Record<string, string>;
  };
}

// === PLUGINS ===

export interface SparkBlockPlugin {
  id: string;
  name: string;
  version?: string;
  dependencies?: string[];
  
  // Lifecycle hooks
  onEditorMount?(engine: SparkBlockEngine): void | Promise<void>;
  onEditorUnmount?(engine: SparkBlockEngine): void | Promise<void>;
  
  // Block lifecycle
  onBlockCreate?(block: SparkBlock): SparkBlock | Promise<SparkBlock>;
  onBlockUpdate?(block: SparkBlock, previousBlock: SparkBlock): SparkBlock | Promise<SparkBlock>;
  onBlockDelete?(block: SparkBlock): void | Promise<void>;
  onBlockMove?(block: SparkBlock, operation: MoveOperation): void | Promise<void>;
  
  // Document lifecycle
  onDocumentLoad?(blocks: SparkBlock[]): SparkBlock[] | Promise<SparkBlock[]>;
  onDocumentSave?(blocks: SparkBlock[]): SparkBlock[] | Promise<SparkBlock[]>;
  
  // UI extensions
  renderToolbar?(): ReactNode;
  renderSidebar?(): ReactNode;
  renderBlockOverlay?(block: SparkBlock, context: RenderContext): ReactNode;
  renderFloatingMenu?(): ReactNode;
  
  // Custom commands
  commands?: Record<string, SparkBlockCommand>;
  
  // Custom block types
  blockTypes?: BlockDefinition[];
  
  // Custom shortcuts
  shortcuts?: Record<string, SparkBlockCommand>;
}

export interface SparkBlockCommand {
  name: string;
  description?: string;
  execute: (engine: SparkBlockEngine, ...args: unknown[]) => void | Promise<void>;
  canExecute?: (engine: SparkBlockEngine) => boolean;
}

// === ENGINE ===

export interface SparkBlockEngineOptions {
  adapter: SparkBlockAdapter;
  plugins?: SparkBlockPlugin[];
  theme?: SparkBlockTheme;
  readonly?: boolean;
  autoSave?: boolean;
  autoSaveDelay?: number;
  maxUndoSteps?: number;
}

export interface SparkBlockEngineState {
  blocks: SparkBlock[];
  selectedBlockIds: string[];
  focusedBlockId: string | null;
  isDirty: boolean;
  isLoading: boolean;
  isSaving: boolean;
  
  // History
  canUndo: boolean;
  canRedo: boolean;
  
  // UI state
  showPlusMenu: boolean;
  plusMenuPosition?: { x: number; y: number };
  showBlockMenu: boolean;
  blockMenuBlockId?: string;
  
  // Drag & drop state
  dragState: {
    isDragging: boolean;
    draggedBlockId?: string;
    dropTarget?: string;
    dropPosition?: 'before' | 'after' | 'inside';
    dropRegion?: string;
  };
}

// === EVENTS ===

export interface SparkBlockEvent<TData = unknown> {
  type: string;
  data: TData;
  timestamp: number;
  blockId?: string;
}

export type SparkBlockEventListener<TData = unknown> = (event: SparkBlockEvent<TData>) => void;

// === ENGINE INTERFACE ===

export interface SparkBlockEngine {
  // State management
  getState(): SparkBlockEngineState;
  subscribe(listener: (state: SparkBlockEngineState) => void): () => void;
  
  // Document lifecycle
  loadDocument<TDocument>(document: TDocument): Promise<void>;
  saveDocument<TDocument>(): Promise<TDocument>;
  
  // Block operations
  createBlock(type: string, position?: InsertPosition, initialData?: Record<string, unknown>): Promise<void>;
  updateBlock(blockId: string, updates: UpdateOperation): Promise<void>;
  deleteBlock(blockId: string): Promise<void>;
  moveBlock(operation: MoveOperation): Promise<void>;
  duplicateBlock(blockId: string, position?: InsertPosition): Promise<void>;
  
  // Block queries
  getBlock(blockId: string): SparkBlock | null;
  getBlocks(): SparkBlock[];
  getSelectedBlocks(): SparkBlock[];
  getFocusedBlock(): SparkBlock | null;
  
  // Selection management
  selectBlock(blockId: string, addToSelection?: boolean): void;
  deselectBlock(blockId: string): void;
  clearSelection(): void;
  focusBlock(blockId: string): void;
  blurBlock(): void;
  
  // History
  undo(): Promise<void>;
  redo(): Promise<void>;
  
  // Commands
  executeCommand(command: string, ...args: unknown[]): Promise<void>;
  registerCommand(name: string, command: SparkBlockCommand): void;
  
  // Events
  emit<TData>(type: string, data: TData, blockId?: string): void;
  on<TData>(type: string, listener: SparkBlockEventListener<TData>): () => void;
  
  // Plugins
  addPlugin(plugin: SparkBlockPlugin): Promise<void>;
  removePlugin(pluginId: string): Promise<void>;
  getPlugin(pluginId: string): SparkBlockPlugin | null;
  
  // Validation
  validateBlock(blockId: string): Promise<ValidationResult>;
  validateDocument(): Promise<ValidationResult>;
  
  // Utility
  destroy(): void;
}

// === ERROR TYPES ===

export declare class SparkBlockError extends Error {
  constructor(
    message: string,
    code?: string,
    blockId?: string
  );
  code?: string;
  blockId?: string;
}

export declare class SparkBlockValidationError extends SparkBlockError {
  constructor(
    message: string,
    validation: ValidationResult,
    blockId?: string
  );
  validation: ValidationResult;
}

export declare class SparkBlockAdapterError extends SparkBlockError {
  constructor(message: string, originalError?: Error);
  originalError?: Error;
}

================================================================================

File: utils/blockOperations.ts
// src/packages/sparkblock/utils/blockOperations.ts

import { nanoid } from 'nanoid';
import type {
  SparkBlock,
  InsertPosition,
  MoveOperation,
  UpdateOperation
} from '../types';

export interface BlockPath {
  blockIndex: number;
  regionName?: string;
  nestedPath?: BlockPath;
}

export interface BlockLocation {
  block: SparkBlock;
  path: BlockPath;
  parent: SparkBlock | null;
  index: number;
}

/**
 * Pure functions for block operations
 */
export class BlockOperations {
  /**
   * Find a block by ID in a nested structure
   */
  static findBlock(blocks: SparkBlock[], targetId: string): BlockLocation | null {
    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      
      if (block.id === targetId) {
        return {
          block,
          path: { blockIndex: i },
          parent: null,
          index: i
        };
      }
      
      // Search in regions
      if (block.regions) {
        for (const [regionName, regionBlocks] of Object.entries(block.regions)) {
          const result = this.findBlock(regionBlocks, targetId);
          if (result) {
            return {
              ...result,
              path: {
                blockIndex: i,
                regionName,
                nestedPath: result.path
              },
              parent: block
            };
          }
        }
      }
    }
    
    return null;
  }

  /**
   * Get all block IDs in order (for navigation)
   */
  static getAllBlockIds(blocks: SparkBlock[]): string[] {
    const ids: string[] = [];
    
    const collectIds = (blockList: SparkBlock[]) => {
      for (const block of blockList) {
        ids.push(block.id);
        if (block.regions) {
          for (const regionBlocks of Object.values(block.regions)) {
            collectIds(regionBlocks);
          }
        }
      }
    };
    
    collectIds(blocks);
    return ids;
  }

  /**
   * Insert a block at a specific position
   */
  static insertBlock(
    blocks: SparkBlock[],
    newBlock: SparkBlock,
    position?: InsertPosition
  ): SparkBlock[] {
    const newBlocks = this.deepClone(blocks);
    
    if (!position || !position.targetId) {
      // Insert at the end
      newBlocks.push(newBlock);
      return newBlocks;
    }

    const target = this.findBlock(newBlocks, position.targetId);
    if (!target) {
      throw new Error(`Target block ${position.targetId} not found`);
    }

    if (position.position === 'inside') {
      // Insert inside a container block
      const regionName = position.regionName || 'default';
      if (!target.block.regions) {
        target.block.regions = {};
      }
      if (!target.block.regions[regionName]) {
        target.block.regions[regionName] = [];
      }
      target.block.regions[regionName].push(newBlock);
    } else {
      // Insert before or after
      const insertIndex = position.position === 'before' ? target.index : target.index + 1;
      
      if (target.parent && target.path.regionName) {
        // Insert in a region
        target.parent.regions![target.path.regionName].splice(insertIndex, 0, newBlock);
      } else {
        // Insert at root level
        newBlocks.splice(insertIndex, 0, newBlock);
      }
    }

    return newBlocks;
  }

  /**
   * Remove a block by ID
   */
  static removeBlock(blocks: SparkBlock[], targetId: string): SparkBlock[] {
    const newBlocks = this.deepClone(blocks);
    const target = this.findBlock(newBlocks, targetId);
    
    if (!target) {
      return blocks; // Block not found, return original
    }

    if (target.parent && target.path.regionName) {
      // Remove from region
      target.parent.regions![target.path.regionName].splice(target.index, 1);
    } else {
      // Remove from root level
      newBlocks.splice(target.index, 1);
    }

    return newBlocks;
  }

  /**
   * Update a block's properties
   */
  static updateBlock(
    blocks: SparkBlock[],
    targetId: string,
    updates: UpdateOperation
  ): SparkBlock[] {
    const newBlocks = this.deepClone(blocks);
    const target = this.findBlock(newBlocks, targetId);
    
    if (!target) {
      return blocks; // Block not found, return original
    }

    if (updates.content) {
      target.block.content = { ...target.block.content, ...updates.content };
    }
    
    if (updates.config) {
      target.block.config = { ...target.block.config, ...updates.config };
    }

    // Update metadata
    if (!target.block.metadata) {
      target.block.metadata = {};
    }
    target.block.metadata.updatedAt = Date.now();
    target.block.metadata.version = (target.block.metadata.version || 0) + 1;

    return newBlocks;
  }

  /**
   * Move a block to a new position
   */
  static moveBlock(blocks: SparkBlock[], operation: MoveOperation): SparkBlock[] {
    const blockToMove = this.findBlock(blocks, operation.blockId);
    if (!blockToMove) {
      throw new Error(`Block ${operation.blockId} not found`);
    }

    // First remove the block
    const blocksWithoutTarget = this.removeBlock(blocks, operation.blockId);
    
    // Then insert it at the new position
    const position: InsertPosition = {
      targetId: operation.targetId,
      position: operation.position,
      regionName: operation.regionName
    };

    return this.insertBlock(blocksWithoutTarget, blockToMove.block, position);
  }

  /**
   * Duplicate a block
   */
  static duplicateBlock(
    blocks: SparkBlock[],
    targetId: string,
    position?: InsertPosition
  ): SparkBlock[] {
    const target = this.findBlock(blocks, targetId);
    if (!target) {
      throw new Error(`Block ${targetId} not found`);
    }

    const duplicatedBlock = this.deepClone(target.block);
    duplicatedBlock.id = nanoid();
    
    // Recursively assign new IDs to nested blocks
    this.assignNewIds(duplicatedBlock);

    // Set creation metadata
    duplicatedBlock.metadata = {
      ...duplicatedBlock.metadata,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      version: 1
    };

    // Insert after the original block if no position specified
    const insertPosition: InsertPosition = position || {
      targetId,
      position: 'after'
    };

    return this.insertBlock(blocks, duplicatedBlock, insertPosition);
  }

  /**
   * Split a block into two blocks at a specific point
   */
  static splitBlock(
    blocks: SparkBlock[],
    targetId: string,
    splitPoint: number,
    contentField: string = 'text'
  ): SparkBlock[] {
    const target = this.findBlock(blocks, targetId);
    if (!target) {
      throw new Error(`Block ${targetId} not found`);
    }

    const originalContent = String(target.block.content[contentField] || '');
    const beforeContent = originalContent.substring(0, splitPoint);
    const afterContent = originalContent.substring(splitPoint);

    // Update the original block
    const updatedBlocks = this.updateBlock(blocks, targetId, {
      blockId: targetId,
      content: { [contentField]: beforeContent }
    });

    // Create new block with the same type
    const newBlock: SparkBlock = {
      id: nanoid(),
      type: target.block.type,
      content: {
        ...target.block.content,
        [contentField]: afterContent
      },
      config: { ...target.block.config },
      regions: {},
      metadata: {
        createdAt: Date.now(),
        updatedAt: Date.now(),
        version: 1
      }
    };

    return this.insertBlock(updatedBlocks, newBlock, {
      targetId,
      position: 'after'
    });
  }

  /**
   * Merge two adjacent blocks
   */
  static mergeBlocks(
    blocks: SparkBlock[],
    firstBlockId: string,
    secondBlockId: string,
    contentField: string = 'text'
  ): SparkBlock[] {
    const firstBlock = this.findBlock(blocks, firstBlockId);
    const secondBlock = this.findBlock(blocks, secondBlockId);

    if (!firstBlock || !secondBlock) {
      throw new Error('One or both blocks not found');
    }

    if (firstBlock.block.type !== secondBlock.block.type) {
      throw new Error('Cannot merge blocks of different types');
    }

    const firstContent = String(firstBlock.block.content[contentField] || '');
    const secondContent = String(secondBlock.block.content[contentField] || '');
    const mergedContent = firstContent + secondContent;

    // Update first block with merged content
    const updatedBlocks = this.updateBlock(blocks, firstBlockId, {
      blockId: firstBlockId,
      content: { [contentField]: mergedContent }
    });

    // Remove second block
    return this.removeBlock(updatedBlocks, secondBlockId);
  }

  /**
   * Convert a block to a different type
   */
  static convertBlock(
    blocks: SparkBlock[],
    targetId: string,
    newType: string,
    contentMapping?: Record<string, string>
  ): SparkBlock[] {
    const target = this.findBlock(blocks, targetId);
    if (!target) {
      throw new Error(`Block ${targetId} not found`);
    }

    const newBlock: SparkBlock = {
      ...target.block,
      type: newType,
      content: {},
      metadata: {
        ...target.block.metadata,
        updatedAt: Date.now(),
        version: (target.block.metadata?.version || 0) + 1
      }
    };

    // Map content fields if mapping provided
    if (contentMapping) {
      for (const [oldField, newField] of Object.entries(contentMapping)) {
        if (target.block.content[oldField] !== undefined) {
          newBlock.content[newField] = target.block.content[oldField];
        }
      }
    } else {
      // Try to preserve compatible fields
      newBlock.content = { ...target.block.content };
    }

    // Replace the block in the structure
    const newBlocks = this.deepClone(blocks);
    const newTarget = this.findBlock(newBlocks, targetId);
    
    if (newTarget) {
      if (newTarget.parent && newTarget.path.regionName) {
        newTarget.parent.regions![newTarget.path.regionName][newTarget.index] = newBlock;
      } else {
        newBlocks[newTarget.index] = newBlock;
      }
    }

    return newBlocks;
  }

  /**
   * Get the nesting level of a block
   */
  static getBlockNestingLevel(blocks: SparkBlock[], targetId: string): number {
    const target = this.findBlock(blocks, targetId);
    if (!target) return 0;

    let level = 0;
    let currentPath = target.path;

    while (currentPath.nestedPath) {
      level++;
      currentPath = currentPath.nestedPath;
    }

    return level;
  }

  /**
   * Get the next/previous block ID for navigation
   */
  static getAdjacentBlockId(
    blocks: SparkBlock[],
    currentId: string,
    direction: 'next' | 'previous'
  ): string | null {
    const allIds = this.getAllBlockIds(blocks);
    const currentIndex = allIds.indexOf(currentId);
    
    if (currentIndex === -1) return null;

    const targetIndex = direction === 'next' ? currentIndex + 1 : currentIndex - 1;
    
    if (targetIndex < 0 || targetIndex >= allIds.length) {
      return null;
    }

    return allIds[targetIndex];
  }

  /**
   * Validate block structure integrity
   */
  static validateStructure(blocks: SparkBlock[]): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    const seenIds = new Set<string>();

    const validateBlock = (block: SparkBlock, path: string) => {
      // Check for duplicate IDs
      if (seenIds.has(block.id)) {
        errors.push(`Duplicate block ID: ${block.id} at ${path}`);
      } else {
        seenIds.add(block.id);
      }

      // Check required fields
      if (!block.id) {
        errors.push(`Block missing ID at ${path}`);
      }
      if (!block.type) {
        errors.push(`Block missing type at ${path}`);
      }
      if (!block.content) {
        errors.push(`Block missing content at ${path}`);
      }

      // Validate regions
      if (block.regions) {
        for (const [regionName, regionBlocks] of Object.entries(block.regions)) {
          if (!Array.isArray(regionBlocks)) {
            errors.push(`Invalid region ${regionName} in block ${block.id}: not an array`);
            continue;
          }

          regionBlocks.forEach((regionBlock, index) => {
            validateBlock(regionBlock, `${path}.regions.${regionName}[${index}]`);
          });
        }
      }
    };

    blocks.forEach((block, index) => {
      validateBlock(block, `blocks[${index}]`);
    });

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Deep clone blocks structure
   */
  private static deepClone<T>(obj: T): T {
    return JSON.parse(JSON.stringify(obj));
  }

  /**
   * Assign new IDs to a block and all nested blocks
   */
  private static assignNewIds(block: SparkBlock): void {
    block.id = nanoid();
    
    if (block.regions) {
      for (const regionBlocks of Object.values(block.regions)) {
        for (const nestedBlock of regionBlocks) {
          this.assignNewIds(nestedBlock);
        }
      }
    }
  }
}

/**
 * Block query utilities
 */
export class BlockQueries {
  /**
   * Filter blocks by type
   */
  static filterByType(blocks: SparkBlock[], type: string): SparkBlock[] {
    const result: SparkBlock[] = [];
    
    const collectByType = (blockList: SparkBlock[]) => {
      for (const block of blockList) {
        if (block.type === type) {
          result.push(block);
        }
        if (block.regions) {
          for (const regionBlocks of Object.values(block.regions)) {
            collectByType(regionBlocks);
          }
        }
      }
    };
    
    collectByType(blocks);
    return result;
  }

  /**
   * Search blocks by content
   */
  static searchByContent(
    blocks: SparkBlock[],
    query: string,
    fields: string[] = ['text', 'title', 'caption']
  ): SparkBlock[] {
    const result: SparkBlock[] = [];
    const lowerQuery = query.toLowerCase();
    
    const searchBlocks = (blockList: SparkBlock[]) => {
      for (const block of blockList) {
        const matches = fields.some(field => {
          const content = block.content[field];
          return content && String(content).toLowerCase().includes(lowerQuery);
        });
        
        if (matches) {
          result.push(block);
        }
        
        if (block.regions) {
          for (const regionBlocks of Object.values(block.regions)) {
            searchBlocks(regionBlocks);
          }
        }
      }
    };
    
    searchBlocks(blocks);
    return result;
  }

  /**
   * Get blocks in a specific region
   */
  static getBlocksByRegion(
    blocks: SparkBlock[],
    containerId: string,
    regionName: string
  ): SparkBlock[] {
    const container = BlockOperations.findBlock(blocks, containerId);
    if (!container || !container.block.regions) {
      return [];
    }

    return container.block.regions[regionName] || [];
  }

  /**
   * Get all container blocks
   */
  static getContainerBlocks(blocks: SparkBlock[]): SparkBlock[] {
    const result: SparkBlock[] = [];
    
    const findContainers = (blockList: SparkBlock[]) => {
      for (const block of blockList) {
        if (block.regions && Object.keys(block.regions).length > 0) {
          result.push(block);
        }
        if (block.regions) {
          for (const regionBlocks of Object.values(block.regions)) {
            findContainers(regionBlocks);
          }
        }
      }
    };
    
    findContainers(blocks);
    return result;
  }

  /**
   * Get block statistics
   */
  static getStatistics(blocks: SparkBlock[]): {
    totalBlocks: number;
    blocksByType: Record<string, number>;
    maxNestingLevel: number;
    containerBlocks: number;
  } {
    let totalBlocks = 0;
    let maxNestingLevel = 0;
    let containerBlocks = 0;
    const blocksByType: Record<string, number> = {};
    
    const analyzeBlocks = (blockList: SparkBlock[], level: number = 0) => {
      maxNestingLevel = Math.max(maxNestingLevel, level);
      
      for (const block of blockList) {
        totalBlocks++;
        blocksByType[block.type] = (blocksByType[block.type] || 0) + 1;
        
        if (block.regions && Object.keys(block.regions).length > 0) {
          containerBlocks++;
          for (const regionBlocks of Object.values(block.regions)) {
            analyzeBlocks(regionBlocks, level + 1);
          }
        }
      }
    };
    
    analyzeBlocks(blocks);
    
    return {
      totalBlocks,
      blocksByType,
      maxNestingLevel,
      containerBlocks
    };
  }
}

================================================================================

File: styles/sparkblock.css
/* src/packages/sparkblock/styles/sparkblock.css */

/* === ROOT STYLES === */
.sparkblock-editor {
  position: relative;
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-size: 14px;
  line-height: 1.5;
  color: #1a1a1a;
  background: #ffffff;
}

.sparkblock-editor:focus {
  outline: none;
}

.sparkblock-readonly {
  pointer-events: none;
}

/* === TOOLBAR === */
.sparkblock-toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border-bottom: 1px solid #e0e0e0;
  background: #f8f9fa;
  flex-shrink: 0;
}

.sparkblock-toolbar-section {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sparkblock-toolbar-section:not(:last-child) {
  margin-right: 12px;
  padding-right: 12px;
  border-right: 1px solid #e0e0e0;
}

.sparkblock-toolbar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 6px;
  background: transparent;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  color: #666666;
  transition: all 0.2s ease;
}

.sparkblock-toolbar-button:hover {
  background: #e3f2fd;
  color: #1976d2;
}

.sparkblock-toolbar-button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.sparkblock-toolbar-plugins {
  margin-left: auto;
}

/* === CANVAS === */
.sparkblock-canvas {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  min-height: 0;
}

.sparkblock-canvas:focus {
  outline: none;
}

.sparkblock-blocks {
  max-width: 800px;
  margin: 0 auto;
}

/* Empty state */
.sparkblock-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 200px;
}

.sparkblock-empty-state {
  text-align: center;
  color: #666666;
}

.sparkblock-empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
}

.sparkblock-empty-text {
  font-size: 16px;
  margin-bottom: 16px;
}

.sparkblock-empty-button {
  padding: 8px 16px;
  background: #1976d2;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s ease;
}

.sparkblock-empty-button:hover {
  background: #1565c0;
}

/* === BLOCKS === */
.sparkblock-block {
  position: relative;
  margin: 4px 0;
  border-radius: 6px;
  transition: all 0.2s ease;
}

.sparkblock-block:hover {
  background: #f8f9fa;
}

.sparkblock-block--selected {
  background: #e3f2fd;
  box-shadow: 0 0 0 2px #1976d2;
}

.sparkblock-block--focused {
  box-shadow: 0 0 0 2px #1976d2;
}

.sparkblock-block--dragging {
  opacity: 0.5;
  transform: rotate(2deg);
}

.sparkblock-block--readonly {
  pointer-events: none;
}

/* Block controls */
.sparkblock-block-controls {
  position: absolute;
  left: -40px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 2px;
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 10;
}

.sparkblock-block-controls--visible {
  opacity: 1;
}

.sparkblock-control {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  cursor: pointer;
  color: #666666;
  transition: all 0.2s ease;
}

.sparkblock-control:hover {
  background: #f0f0f0;
  color: #1976d2;
  border-color: #1976d2;
}

.sparkblock-control--drag {
  cursor: grab;
}

.sparkblock-control--drag:active {
  cursor: grabbing;
}

/* Block content */
.sparkblock-block-content {
  padding: 8px 12px;
  min-height: 1.5em;
}

/* === BLOCK TYPES === */

/* Paragraph */
.sparkblock-paragraph {
  outline: none;
  min-height: 1.5em;
  white-space: pre-wrap;
}

.sparkblock-paragraph:empty::before {
  content: attr(data-placeholder);
  color: #999999;
  pointer-events: none;
}

/* Headings */
.sparkblock-heading {
  outline: none;
  font-weight: bold;
  margin: 0;
  min-height: 1.2em;
}

.sparkblock-heading--1 {
  font-size: 32px;
  line-height: 1.2;
}

.sparkblock-heading--2 {
  font-size: 24px;
  line-height: 1.3;
}

.sparkblock-heading--3 {
  font-size: 20px;
  line-height: 1.4;
}

.sparkblock-heading--4 {
  font-size: 18px;
  line-height: 1.4;
}

.sparkblock-heading--5 {
  font-size: 16px;
  line-height: 1.5;
}

.sparkblock-heading--6 {
  font-size: 14px;
  line-height: 1.5;
}

.sparkblock-heading:empty::before {
  content: attr(data-placeholder);
  color: #999999;
  pointer-events: none;
}

/* Quote */
.sparkblock-quote {
  margin: 0;
  padding-left: 16px;
  border-left: 4px solid #e0e0e0;
  font-style: italic;
}

.sparkblock-quote-text {
  outline: none;
  min-height: 1.5em;
}

.sparkblock-quote-text:empty::before {
  content: attr(data-placeholder);
  color: #999999;
  pointer-events: none;
}

.sparkblock-quote-author {
  display: block;
  margin-top: 8px;
  font-size: 14px;
  color: #666666;
  font-style: normal;
}

/* Code */
.sparkblock-code-block {
  background: #f5f5f5;
  border-radius: 6px;
  overflow: hidden;
}

.sparkblock-code-language {
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 500;
  color: #666666;
  background: #eeeeee;
  border-bottom: 1px solid #e0e0e0;
}

.sparkblock-code {
  outline: none;
  padding: 12px;
  margin: 0;
  font-family: Monaco, Consolas, "Courier New", monospace;
  font-size: 13px;
  line-height: 1.4;
  white-space: pre-wrap;
  overflow-x: auto;
  background: transparent;
}

.sparkblock-code:empty::before {
  content: attr(data-placeholder);
  color: #999999;
  pointer-events: none;
}

/* List */
.sparkblock-list {
  display: flex;
  align-items: flex-start;
  gap: 8px;
}

.sparkblock-list-marker {
  color: #666666;
  font-weight: 500;
  margin-top: 1px;
  min-width: 16px;
}

.sparkblock-list-content {
  flex: 1;
  outline: none;
  min-height: 1.5em;
}

.sparkblock-list-content:empty::before {
  content: attr(data-placeholder);
  color: #999999;
  pointer-events: none;
}

/* Image */
.sparkblock-image {
  text-align: center;
}

.sparkblock-image--empty {
  padding: 40px;
  border: 2px dashed #e0e0e0;
  border-radius: 8px;
  color: #666666;
}

.sparkblock-image-placeholder {
  font-size: 16px;
  cursor: pointer;
}

.sparkblock-image-element {
  max-width: 100%;
  height: auto;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.sparkblock-image-caption {
  margin-top: 8px;
  font-size: 14px;
  color: #666666;
  font-style: italic;
  outline: none;
}

.sparkblock-image-caption:empty::before {
  content: attr(data-placeholder);
  color: #999999;
  pointer-events: none;
}

/* Divider */
.sparkblock-divider {
  margin: 16px 0;
}

.sparkblock-divider hr {
  border: none;
  height: 1px;
  background: #e0e0e0;
  margin: 0;
}

/* Unknown block */
.sparkblock-unknown {
  padding: 16px;
  background: #fff3cd;
  border: 1px solid #ffeaa7;
  border-radius: 6px;
  color: #856404;
}

.sparkblock-unknown-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
}

.sparkblock-unknown-type {
  font-weight: 500;
}

.sparkblock-unknown-content {
  font-family: Monaco, Consolas, "Courier New", monospace;
  font-size: 12px;
  max-height: 200px;
  overflow: auto;
  background: rgba(255, 255, 255, 0.5);
  padding: 8px;
  border-radius: 4px;
}

/* === REGIONS === */
.sparkblock-region {
  margin: 8px 0;
  padding: 8px;
  border: 1px dashed #e0e0e0;
  border-radius: 6px;
  background: #fafafa;
}

.sparkblock-region-label {
  font-size: 12px;
  font-weight: 500;
  color: #666666;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.sparkblock-region-content {
  min-height: 40px;
}

.sparkblock-region-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  color: #999999;
  font-style: italic;
  cursor: pointer;
  border-radius: 4px;
  transition: background 0.2s ease;
}

.sparkblock-region-empty:hover {
  background: #f0f0f0;
}

/* === MENUS === */

/* Plus Menu */
.sparkblock-plus-menu {
  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  min-width: 300px;
  max-width: 400px;
  max-height: 400px;
  overflow: hidden;
}

.sparkblock-plus-menu-header {
  display: flex;
  align-items: center;
  padding: 12px;
  border-bottom: 1px solid #e0e0e0;
}

.sparkblock-plus-menu-search {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  font-size: 14px;
  outline: none;
}

.sparkblock-plus-menu-search:focus {
  border-color: #1976d2;
}

.sparkblock-plus-menu-close {
  margin-left: 8px;
  padding: 4px;
  background: transparent;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  color: #666666;
}

.sparkblock-plus-menu-close:hover {
  background: #f0f0f0;
}

.sparkblock-plus-menu-content {
  max-height: 300px;
  overflow-y: auto;
}

.sparkblock-plus-menu-empty {
  padding: 20px;
  text-align: center;
  color: #666666;
  font-style: italic;
}

.sparkblock-plus-menu-category {
  padding: 8px 0;
}

.sparkblock-plus-menu-category-title {
  padding: 8px 16px;
  font-size: 12px;
  font-weight: 600;
  color: #666666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  background: #f8f9fa;
}

.sparkblock-plus-menu-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  background: transparent;
  border: none;
  width: 100%;
  text-align: left;
  cursor: pointer;
  transition: background 0.2s ease;
}

.sparkblock-plus-menu-item:hover,
.sparkblock-plus-menu-item--selected {
  background: #f0f0f0;
}

.sparkblock-plus-menu-item-icon {
  flex-shrink: 0;
  color: #666666;
}

.sparkblock-plus-menu-item-content {
  flex: 1;
  min-width: 0;
}

.sparkblock-plus-menu-item-name {
  font-weight: 500;
  color: #1a1a1a;
  margin-bottom: 2px;
}

.sparkblock-plus-menu-item-description {
  font-size: 12px;
  color: #666666;
  line-height: 1.3;
}

/* Block Menu */
.sparkblock-block-menu {
  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  min-width: 200px;
  overflow: hidden;
}

.sparkblock-block-menu-header {
  padding: 12px 16px;
  border-bottom: 1px solid #e0e0e0;
  background: #f8f9fa;
}

.sparkblock-block-menu-title {
  font-weight: 500;
  color: #1a1a1a;
}

.sparkblock-block-menu-type {
  font-size: 12px;
  color: #666666;
  margin-top: 2px;
}

.sparkblock-block-menu-content {
  padding: 8px 0;
}

.sparkblock-block-menu-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: transparent;
  border: none;
  width: 100%;
  text-align: left;
  cursor: pointer;
  color: #1a1a1a;
  font-size: 14px;
  transition: background 0.2s ease;
}

.sparkblock-block-menu-item:hover {
  background: #f0f0f0;
}

.sparkblock-block-menu-item--danger {
  color: #d32f2f;
}

.sparkblock-block-menu-item--danger:hover {
  background: #ffebee;
}

.sparkblock-block-menu-divider {
  height: 1px;
  background: #e0e0e0;
  margin: 4px 0;
}

/* Floating Toolbar */
.sparkblock-floating-toolbar {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 8px;
  background: #1a1a1a;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.sparkblock-floating-toolbar-section {
  display: flex;
  align-items: center;
  gap: 2px;
}

.sparkblock-floating-toolbar-section:not(:last-child) {
  margin-right: 8px;
  padding-right: 8px;
  border-right: 1px solid #444444;
}

.sparkblock-floating-toolbar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 6px;
  background: transparent;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  color: #ffffff;
  transition: background 0.2s ease;
}

.sparkblock-floating-toolbar-button:hover {
  background: #333333;
}

.sparkblock-floating-toolbar-button--danger {
  color: #ff5252;
}

.sparkblock-floating-toolbar-button--danger:hover {
  background: #331111;
}

.sparkblock-floating-toolbar-info {
  font-size: 12px;
  color: #cccccc;
  margin-left: 8px;
}

/* === LOADING AND STATES === */
.sparkblock-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 200px;
}

.sparkblock-loading-content {
  text-align: center;
  color: #666666;
}

.sparkblock-spinner {
  width: 32px;
  height: 32px;
  border: 3px solid #e0e0e0;
  border-top: 3px solid #1976d2;
  border-radius: 50%;
  animation: sparkblock-spin 1s linear infinite;
  margin: 0 auto 16px;
}

@keyframes sparkblock-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.sparkblock-error {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 200px;
}

.sparkblock-error-content {
  text-align: center;
  color: #d32f2f;
}

.sparkblock-error-content h3 {
  margin: 0 0 8px 0;
  font-size: 18px;
}

.sparkblock-error-content p {
  margin: 0 0 16px 0;
  color: #666666;
}

.sparkblock-error-content button {
  padding: 8px 16px;
  background: #d32f2f;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
}

.sparkblock-save-indicator {
  position: fixed;
  bottom: 16px;
  right: 16px;
  padding: 8px 12px;
  background: #4caf50;
  color: white;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  z-index: 1000;
}

/* === RESPONSIVE === */
@media (max-width: 768px) {
  .sparkblock-canvas {
    padding: 12px;
  }
  
  .sparkblock-blocks {
    max-width: 100%;
  }
  
  .sparkblock-plus-menu,
  .sparkblock-block-menu {
    max-width: 90vw;
  }
  
  .sparkblock-floating-toolbar {
    transform: scale(0.9);
  }
}

================================================================================

File: components/BlockCanvas.tsx
// src/packages/sparkblock/components/BlockCanvas.tsx

import React, { useCallback, useRef, useEffect } from 'react';
import type { SparkBlock, RenderContext } from '../types';
import { BlockRenderer } from './BlockRenderer';
import { useSparkBlock } from './SparkBlockProvider';

export interface BlockCanvasProps {
  blocks: SparkBlock[];
  selectedBlockIds: string[];
  focusedBlockId: string | null;
  dragState: {
    isDragging: boolean;
    draggedBlockId?: string;
    dropTarget?: string;
    dropPosition?: 'before' | 'after' | 'inside';
    dropRegion?: string;
  };
  readonly: boolean;
  placeholder?: string;
  renderBlock?: (block: SparkBlock, context: RenderContext) => React.ReactNode;
}

export function BlockCanvas({
  blocks,
  selectedBlockIds,
  focusedBlockId,
  dragState,
  readonly,
  placeholder = "Start writing...",
  renderBlock
}: BlockCanvasProps) {
  const { engine, theme } = useSparkBlock();
  const canvasRef = useRef<HTMLDivElement>(null);

  // Handle drop events
  const handleDragOver = useCallback((event: React.DragEvent) => {
    if (readonly) return;
    
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
    
    // TODO: Implement drop target detection
    // This would calculate which block and position to drop at
  }, [readonly]);

  const handleDrop = useCallback((event: React.DragEvent) => {
    if (readonly) return;
    
    event.preventDefault();
    
    // TODO: Implement actual drop logic
    // This would use the dragState to move the block
    const { draggedBlockId, dropTarget, dropPosition, dropRegion } = dragState;
    
    if (draggedBlockId && dropTarget && dropPosition) {
      engine.moveBlock({
        blockId: draggedBlockId,
        targetId: dropTarget,
        position: dropPosition,
        regionName: dropRegion
      });
    }
  }, [readonly, dragState, engine]);

  // Handle click outside to clear selection
  const handleCanvasClick = useCallback((event: React.MouseEvent) => {
    if (readonly) return;
    
    const target = event.target as HTMLElement;
    
    // Only clear selection if clicking on the canvas itself, not on blocks
    if (target === canvasRef.current) {
      engine.clearSelection();
      engine.blurBlock();
    }
  }, [readonly, engine]);

  // Handle slash command
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    if (readonly) return;

    if (event.key === '/' && !focusedBlockId) {
      event.preventDefault();
      // TODO: Show command palette or block type menu
      // This would be a global slash command when no block is focused
    }
  }, [readonly, focusedBlockId]);

  // Auto-focus first block if none focused and blocks exist
  useEffect(() => {
    if (!readonly && blocks.length > 0 && !focusedBlockId) {
      // Only auto-focus if the canvas is focused
      if (document.activeElement === canvasRef.current) {
        engine.focusBlock(blocks[0].id);
      }
    }
  }, [blocks, focusedBlockId, readonly, engine]);

  // Render empty state
  if (blocks.length === 0) {
    return (
      <div 
        ref={canvasRef}
        className="sparkblock-canvas sparkblock-empty"
        onClick={handleCanvasClick}
        onKeyDown={handleKeyDown}
        tabIndex={0}
      >
        <div className="sparkblock-empty-state">
          <div className="sparkblock-empty-icon">✍️</div>
          <p className="sparkblock-empty-text">{placeholder}</p>
          {!readonly && (
            <button 
              className="sparkblock-empty-button"
              onClick={() => engine.createBlock('paragraph')}
            >
              Start writing
            </button>
          )}
        </div>
      </div>
    );
  }

  // Render blocks
  return (
    <div 
      ref={canvasRef}
      className="sparkblock-canvas"
      onClick={handleCanvasClick}
      onKeyDown={handleKeyDown}
      onDragOver={handleDragOver}
      onDrop={handleDrop}
      tabIndex={0}
    >
      <div className="sparkblock-blocks">
        {blocks.map((block, index) => (
          <BlockRenderer
            key={block.id}
            block={block}
            isSelected={selectedBlockIds.includes(block.id)}
            isFocused={focusedBlockId === block.id}
            isDragging={dragState.draggedBlockId === block.id}
            nestingLevel={0}
            readonly={readonly}
            renderBlock={renderBlock}
            showControls={!readonly}
          />
        ))}
      </div>

      {/* Drop indicators */}
      {dragState.isDragging && (
        <div className="sparkblock-drop-indicators">
          {/* TODO: Render drop zone indicators */}
        </div>
      )}
    </div>
  );
}

================================================================================

File: components/SparkBlockEditor.tsx
// src/packages/sparkblock/components/SparkBlockEditor.tsx

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import type {
  SparkBlock,
  SparkBlockAdapter,
  SparkBlockEngine,
  SparkBlockEngineState,
  SparkBlockPlugin,
  SparkBlockTheme,
  RenderContext
} from '../types';
import { createSparkBlockEngine } from '../engine/SparkBlockEngine';
import { SparkBlockProvider } from './SparkBlockProvider';
import { BlockCanvas } from './BlockCanvas';
import { BlockToolbar } from './BlockToolbar';
import { PlusMenu } from './PlusMenu';
import { BlockMenu } from './BlockMenu';
import { FloatingToolbar } from './FloatingToolbar';

export interface SparkBlockEditorProps<TDocument = unknown> {
  adapter: SparkBlockAdapter<TDocument>;
  document: TDocument;
  onDocumentChange?: (document: TDocument) => void;
  
  // Optional customization
  theme?: SparkBlockTheme;
  plugins?: SparkBlockPlugin[];
  renderBlock?: (block: SparkBlock, context: RenderContext) => React.ReactNode;
  
  // Editor configuration
  readonly?: boolean;
  autoSave?: boolean;
  autoSaveDelay?: number;
  placeholder?: string;
  className?: string;
  style?: React.CSSProperties;
  
  // Event handlers
  onReady?: (engine: SparkBlockEngine) => void;
  onError?: (error: Error) => void;
  onSelectionChange?: (selectedBlockIds: string[]) => void;
  onFocusChange?: (focusedBlockId: string | null) => void;
}

export function SparkBlockEditor<TDocument = unknown>({
  adapter,
  document,
  onDocumentChange,
  theme,
  plugins = [],
  renderBlock,
  readonly = false,
  autoSave = true,
  autoSaveDelay = 1000,
  placeholder = "Start writing or press '/' for commands...",
  className = '',
  style,
  onReady,
  onError,
  onSelectionChange,
  onFocusChange
}: SparkBlockEditorProps<TDocument>) {
  // Create engine instance
  const engine = useMemo(() => {
    try {
      return createSparkBlockEngine({
        adapter,
        plugins,
        theme,
        readonly,
        autoSave,
        autoSaveDelay
      });
    } catch (error) {
      onError?.(error as Error);
      throw error;
    }
  }, [adapter, plugins, theme, readonly, autoSave, autoSaveDelay, onError]);

  // Engine state
  const [engineState, setEngineState] = useState<SparkBlockEngineState>(() => engine.getState());
  const [isReady, setIsReady] = useState(false);
  const [loadError, setLoadError] = useState<Error | null>(null);

  // Subscribe to engine state changes
  useEffect(() => {
    const unsubscribe = engine.subscribe(setEngineState);
    return unsubscribe;
  }, [engine]);

  // Load document
  useEffect(() => {
    let isMounted = true;
    
    const loadDocument = async () => {
      try {
        setLoadError(null);
        setIsReady(false);
        
        await engine.loadDocument(document);
        
        if (isMounted) {
          setIsReady(true);
          onReady?.(engine);
        }
      } catch (error) {
        if (isMounted) {
          const err = error as Error;
          setLoadError(err);
          onError?.(err);
        }
      }
    };

    loadDocument();

    return () => {
      isMounted = false;
    };
  }, [document, engine, onReady, onError]);

  // Auto-save when blocks change
  useEffect(() => {
    if (!isReady || !autoSave || !onDocumentChange) return;

    let timeoutId: NodeJS.Timeout;
    
    const handleSave = async () => {
      if (engineState.isDirty) {
        try {
          const savedDocument = await engine.saveDocument<TDocument>();
          onDocumentChange(savedDocument);
        } catch (error) {
          onError?.(error as Error);
        }
      }
    };

    // Debounce auto-save
    timeoutId = setTimeout(handleSave, autoSaveDelay);

    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [engineState.blocks, engineState.isDirty, isReady, autoSave, autoSaveDelay, engine, onDocumentChange, onError]);

  // Handle selection changes
  useEffect(() => {
    onSelectionChange?.(engineState.selectedBlockIds);
  }, [engineState.selectedBlockIds, onSelectionChange]);

  // Handle focus changes
  useEffect(() => {
    onFocusChange?.(engineState.focusedBlockId);
  }, [engineState.focusedBlockId, onFocusChange]);

  // Handle keyboard shortcuts
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    if (readonly) return;

    const { key, metaKey, ctrlKey, shiftKey, altKey } = event;
    const isModified = metaKey || ctrlKey;

    // Global shortcuts
    if (isModified) {
      switch (key) {
        case 'z':
          event.preventDefault();
          if (shiftKey) {
            engine.redo();
          } else {
            engine.undo();
          }
          break;
          
        case 'a':
          event.preventDefault();
          engine.executeCommand('select-all');
          break;
          
        case 's':
          event.preventDefault();
          if (onDocumentChange) {
            engine.saveDocument<TDocument>()
              .then(onDocumentChange)
              .catch(onError);
          }
          break;
      }
    }

    // Delete selected blocks
    if (key === 'Backspace' && engineState.selectedBlockIds.length > 0) {
      const target = event.target as HTMLElement;
      
      // Only delete if not inside an editable element
      if (!target.isContentEditable && target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
        event.preventDefault();
        engine.executeCommand('delete-selected');
      }
    }
  }, [readonly, engine, engineState.selectedBlockIds, onDocumentChange, onError]);

  // Render loading state
  if (engineState.isLoading) {
    return (
      <div className={`sparkblock-editor sparkblock-loading ${className}`} style={style}>
        <div className="sparkblock-loading-content">
          <div className="sparkblock-spinner" />
          <p>Loading editor...</p>
        </div>
      </div>
    );
  }

  // Render error state
  if (loadError) {
    return (
      <div className={`sparkblock-editor sparkblock-error ${className}`} style={style}>
        <div className="sparkblock-error-content">
          <h3>Failed to load editor</h3>
          <p>{loadError.message}</p>
          <button onClick={() => window.location.reload()}>
            Reload
          </button>
        </div>
      </div>
    );
  }

  // Render editor
  return (
    <SparkBlockProvider engine={engine} theme={theme} readonly={readonly}>
      <div 
        className={`sparkblock-editor ${readonly ? 'sparkblock-readonly' : ''} ${className}`}
        style={style}
        onKeyDown={handleKeyDown}
        tabIndex={0}
      >
        {/* Main toolbar */}
        {!readonly && (
          <BlockToolbar 
            engine={engine}
            state={engineState}
            plugins={plugins}
          />
        )}

        {/* Editor canvas */}
        <BlockCanvas
          blocks={engineState.blocks}
          selectedBlockIds={engineState.selectedBlockIds}
          focusedBlockId={engineState.focusedBlockId}
          dragState={engineState.dragState}
          readonly={readonly}
          placeholder={placeholder}
          renderBlock={renderBlock}
        />

        {/* Plus menu */}
        {!readonly && engineState.showPlusMenu && engineState.plusMenuPosition && (
          <PlusMenu
            position={engineState.plusMenuPosition}
            onClose={() => engine.setState({ showPlusMenu: false, plusMenuPosition: undefined })}
          />
        )}

        {/* Block context menu */}
        {!readonly && engineState.showBlockMenu && engineState.blockMenuBlockId && (
          <BlockMenu
            blockId={engineState.blockMenuBlockId}
            onClose={() => engine.setState({ showBlockMenu: false, blockMenuBlockId: undefined })}
          />
        )}

        {/* Floating toolbar for selected blocks */}
        {!readonly && engineState.selectedBlockIds.length > 0 && (
          <FloatingToolbar
            selectedBlockIds={engineState.selectedBlockIds}
          />
        )}

        {/* Plugin UI extensions */}
        {plugins.map(plugin => (
          <React.Fragment key={plugin.id}>
            {plugin.renderFloatingMenu?.()}
          </React.Fragment>
        ))}

        {/* Save indicator */}
        {engineState.isSaving && (
          <div className="sparkblock-save-indicator">
            Saving...
          </div>
        )}
      </div>
    </SparkBlockProvider>
  );
}

// Export hook for accessing engine in child components
export { useSparkBlock } from './SparkBlockProvider';

================================================================================

File: components/BlockMenu.tsx
// src/packages/sparkblock/components/BlockMenu.tsx

import React, { useEffect, useRef } from 'react';
import { Copy, Trash2, MoveUp, MoveDown, MoreHorizontal } from 'lucide-react';
import { useSparkBlock } from './SparkBlockProvider';

export interface BlockMenuProps {
  blockId: string;
  onClose: () => void;
}

export function BlockMenu({ blockId, onClose }: BlockMenuProps) {
  const { engine } = useSparkBlock();
  const menuRef = useRef<HTMLDivElement>(null);

  const block = engine.getBlock(blockId);
  if (!block) {
    onClose();
    return null;
  }

  // Handle click outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        onClose();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [onClose]);

  // Handle escape key
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [onClose]);

  const handleDuplicate = async () => {
    try {
      await engine.duplicateBlock(blockId);
      onClose();
    } catch (error) {
      console.error('Failed to duplicate block:', error);
    }
  };

  const handleDelete = async () => {
    try {
      await engine.deleteBlock(blockId);
      onClose();
    } catch (error) {
      console.error('Failed to delete block:', error);
    }
  };

  const handleMoveUp = async () => {
    try {
      // TODO: Implement move up logic
      // This would require finding the previous block and moving before it
      onClose();
    } catch (error) {
      console.error('Failed to move block up:', error);
    }
  };

  const handleMoveDown = async () => {
    try {
      // TODO: Implement move down logic
      // This would require finding the next block and moving after it
      onClose();
    } catch (error) {
      console.error('Failed to move block down:', error);
    }
  };

  // Get block element to position menu
  const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
  const rect = blockElement?.getBoundingClientRect();
  
  const position = rect ? {
    left: rect.right - 200, // Position to the right of the block
    top: rect.top
  } : { left: 0, top: 0 };

  return (
    <div
      ref={menuRef}
      className="sparkblock-block-menu"
      style={{
        position: 'fixed',
        left: position.left,
        top: position.top,
        zIndex: 1000
      }}
    >
      <div className="sparkblock-block-menu-header">
        <span className="sparkblock-block-menu-title">Block Options</span>
        <span className="sparkblock-block-menu-type">{block.type}</span>
      </div>

      <div className="sparkblock-block-menu-content">
        <button
          className="sparkblock-block-menu-item"
          onClick={handleDuplicate}
        >
          <Copy size={14} />
          <span>Duplicate</span>
        </button>

        <button
          className="sparkblock-block-menu-item"
          onClick={handleMoveUp}
        >
          <MoveUp size={14} />
          <span>Move up</span>
        </button>

        <button
          className="sparkblock-block-menu-item"
          onClick={handleMoveDown}
        >
          <MoveDown size={14} />
          <span>Move down</span>
        </button>

        <div className="sparkblock-block-menu-divider" />

        <button
          className="sparkblock-block-menu-item sparkblock-block-menu-item--danger"
          onClick={handleDelete}
        >
          <Trash2 size={14} />
          <span>Delete</span>
        </button>
      </div>
    </div>
  );
}

================================================================================

File: components/FloatingToolbar.tsx
// src/packages/sparkblock/components/FloatingToolbar.tsx

import React, { useEffect, useRef, useState } from 'react';
import { Bold, Italic, Link, Trash2, Copy } from 'lucide-react';
import { useSparkBlock } from './SparkBlockProvider';

export interface FloatingToolbarProps {
  selectedBlockIds: string[];
}

export function FloatingToolbar({ selectedBlockIds }: FloatingToolbarProps) {
  const { engine } = useSparkBlock();
  const toolbarRef = useRef<HTMLDivElement>(null);
  const [position, setPosition] = useState({ top: 0, left: 0 });

  // Calculate position based on selected blocks
  useEffect(() => {
    if (selectedBlockIds.length === 0) return;

    const updatePosition = () => {
      const blockElements = selectedBlockIds
        .map(id => document.querySelector(`[data-block-id="${id}"]`))
        .filter(Boolean);

      if (blockElements.length === 0) return;

      // Calculate bounding box of all selected blocks
      let minTop = Infinity;
      let maxBottom = -Infinity;
      let minLeft = Infinity;
      let maxRight = -Infinity;

      blockElements.forEach(element => {
        const rect = element!.getBoundingClientRect();
        minTop = Math.min(minTop, rect.top);
        maxBottom = Math.max(maxBottom, rect.bottom);
        minLeft = Math.min(minLeft, rect.left);
        maxRight = Math.max(maxRight, rect.right);
      });

      // Position toolbar above the selection
      const centerX = (minLeft + maxRight) / 2;
      const toolbarWidth = 200; // Approximate width
      
      setPosition({
        top: minTop - 50, // 50px above the selection
        left: centerX - toolbarWidth / 2
      });
    };

    updatePosition();

    // Update position on scroll or resize
    const handleUpdate = () => updatePosition();
    window.addEventListener('scroll', handleUpdate);
    window.addEventListener('resize', handleUpdate);

    return () => {
      window.removeEventListener('scroll', handleUpdate);
      window.removeEventListener('resize', handleUpdate);
    };
  }, [selectedBlockIds]);

  const handleDelete = async () => {
    try {
      await engine.executeCommand('delete-selected');
    } catch (error) {
      console.error('Failed to delete selected blocks:', error);
    }
  };

  const handleDuplicate = async () => {
    try {
      // Duplicate each selected block
      for (const blockId of selectedBlockIds) {
        await engine.duplicateBlock(blockId);
      }
    } catch (error) {
      console.error('Failed to duplicate selected blocks:', error);
    }
  };

  const handleFormat = (format: string) => {
    // TODO: Implement text formatting
    // This would apply formatting to the selected text/blocks
    console.log('Format:', format);
  };

  if (selectedBlockIds.length === 0) return null;

  return (
    <div
      ref={toolbarRef}
      className="sparkblock-floating-toolbar"
      style={{
        position: 'fixed',
        top: position.top,
        left: position.left,
        zIndex: 1000
      }}
    >
      {/* Text formatting (when single block is selected) */}
      {selectedBlockIds.length === 1 && (
        <div className="sparkblock-floating-toolbar-section">
          <button
            className="sparkblock-floating-toolbar-button"
            onClick={() => handleFormat('bold')}
            title="Bold"
          >
            <Bold size={14} />
          </button>
          
          <button
            className="sparkblock-floating-toolbar-button"
            onClick={() => handleFormat('italic')}
            title="Italic"
          >
            <Italic size={14} />
          </button>
          
          <button
            className="sparkblock-floating-toolbar-button"
            onClick={() => handleFormat('link')}
            title="Link"
          >
            <Link size={14} />
          </button>
        </div>
      )}

      {/* Block actions */}
      <div className="sparkblock-floating-toolbar-section">
        <button
          className="sparkblock-floating-toolbar-button"
          onClick={handleDuplicate}
          title="Duplicate"
        >
          <Copy size={14} />
        </button>
        
        <button
          className="sparkblock-floating-toolbar-button sparkblock-floating-toolbar-button--danger"
          onClick={handleDelete}
          title="Delete"
        >
          <Trash2 size={14} />
        </button>
      </div>

      {/* Selection info */}
      <div className="sparkblock-floating-toolbar-info">
        {selectedBlockIds.length} block{selectedBlockIds.length > 1 ? 's' : ''} selected
      </div>
    </div>
  );
}

================================================================================

File: components/BlockRenderer.tsx
// src/packages/sparkblock/components/BlockRenderer.tsx

import React, { useCallback, useRef, useState, useEffect } from 'react';
import { GripVertical, Plus, MoreHorizontal } from 'lucide-react';
import type { SparkBlock, RenderContext } from '../types';
import { useSparkBlock } from './SparkBlockProvider';
import { DefaultBlockRenderers } from './blocks/DefaultBlockRenderers';

export interface BlockRendererProps {
  block: SparkBlock;
  isSelected: boolean;
  isFocused: boolean;
  isDragging: boolean;
  nestingLevel: number;
  readonly: boolean;
  showControls?: boolean;
  renderBlock?: (block: SparkBlock, context: RenderContext) => React.ReactNode;
}

export function BlockRenderer({
  block,
  isSelected,
  isFocused,
  isDragging,
  nestingLevel,
  readonly,
  showControls = true,
  renderBlock
}: BlockRendererProps) {
  const { engine, theme } = useSparkBlock();
  const blockRef = useRef<HTMLDivElement>(null);
  const [showBlockControls, setShowBlockControls] = useState(false);

  // Handle block focus
  const handleFocus = useCallback(() => {
    if (readonly) return;
    engine.focusBlock(block.id);
  }, [readonly, engine, block.id]);

  // Handle block selection
  const handleClick = useCallback((event: React.MouseEvent) => {
    if (readonly) return;
    
    event.stopPropagation();
    
    if (event.metaKey || event.ctrlKey) {
      // Multi-select
      if (isSelected) {
        engine.deselectBlock(block.id);
      } else {
        engine.selectBlock(block.id, true);
      }
    } else {
      // Single select
      engine.selectBlock(block.id);
      engine.focusBlock(block.id);
    }
  }, [readonly, engine, block.id, isSelected]);

  // Handle content changes
  const handleContentChange = useCallback((content: Record<string, unknown>) => {
    if (readonly) return;
    engine.updateBlock(block.id, { content });
  }, [readonly, engine, block.id]);

  // Handle key down events
  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    if (readonly) return;

    switch (event.key) {
      case 'Enter':
        if (!event.shiftKey) {
          event.preventDefault();
          // Create new block after current
          engine.createBlock('paragraph', {
            targetId: block.id,
            position: 'after'
          });
        }
        break;
        
      case 'Backspace':
        // Delete block if empty and at start
        if (isEmptyBlock(block)) {
          event.preventDefault();
          engine.deleteBlock(block.id);
        }
        break;
        
      case '/':
        // Show block type menu
        if (isEmptyBlock(block)) {
          event.preventDefault();
          // TODO: Show block type menu
        }
        break;
        
      case 'ArrowUp':
        if (event.metaKey || event.ctrlKey) {
          event.preventDefault();
          // Focus previous block
          // TODO: Implement navigation
        }
        break;
        
      case 'ArrowDown':
        if (event.metaKey || event.ctrlKey) {
          event.preventDefault();
          // Focus next block
          // TODO: Implement navigation
        }
        break;
    }
  }, [readonly, engine, block]);

  // Handle drag start
  const handleDragStart = useCallback((event: React.DragEvent) => {
    if (readonly) return;
    
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', block.id);
    
    // TODO: Update drag state in engine
  }, [readonly, block.id]);

  // Handle plus button click
  const handlePlusClick = useCallback((event: React.MouseEvent) => {
    if (readonly) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    const rect = blockRef.current?.getBoundingClientRect();
    if (rect) {
      // TODO: Show plus menu
      // engine.setState({ 
      //   showPlusMenu: true, 
      //   plusMenuPosition: { x: rect.left - 40, y: rect.top } 
      // });
    }
  }, [readonly]);

  // Handle block menu click
  const handleMenuClick = useCallback((event: React.MouseEvent) => {
    if (readonly) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    // TODO: Show block context menu
    // engine.setState({ 
    //   showBlockMenu: true, 
    //   blockMenuBlockId: block.id 
    // });
  }, [readonly, block.id]);

  // Create render context
  const renderContext: RenderContext = {
    isEditing: !readonly,
    isSelected,
    isFocused,
    isDragging,
    nestingLevel,
    readonly,
    theme,
    onFocus: handleFocus,
    onChange: handleContentChange,
    onKeyDown: handleKeyDown
  };

  // Get block content renderer
  const getBlockRenderer = useCallback(() => {
    if (renderBlock) {
      return renderBlock(block, renderContext);
    }
    
    // Use default renderers
    const DefaultRenderer = DefaultBlockRenderers[block.type];
    if (DefaultRenderer) {
      return <DefaultRenderer block={block} context={renderContext} />;
    }
    
    // Fallback to unknown block renderer
    return <DefaultBlockRenderers.unknown block={block} context={renderContext} />;
  }, [block, renderContext, renderBlock]);

  // Mouse enter/leave for controls
  const handleMouseEnter = useCallback(() => {
    if (!readonly && showControls) {
      setShowBlockControls(true);
    }
  }, [readonly, showControls]);

  const handleMouseLeave = useCallback(() => {
    if (!isFocused) {
      setShowBlockControls(false);
    }
  }, [isFocused]);

  // Show controls when focused
  useEffect(() => {
    if (isFocused && showControls) {
      setShowBlockControls(true);
    } else if (!isFocused) {
      setShowBlockControls(false);
    }
  }, [isFocused, showControls]);

  return (
    <div
      ref={blockRef}
      className={`
        sparkblock-block 
        ${isSelected ? 'sparkblock-block--selected' : ''}
        ${isFocused ? 'sparkblock-block--focused' : ''}
        ${isDragging ? 'sparkblock-block--dragging' : ''}
        ${readonly ? 'sparkblock-block--readonly' : ''}
      `}
      style={{
        paddingLeft: `${nestingLevel * 20}px`
      }}
      onClick={handleClick}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      draggable={!readonly && showControls}
      onDragStart={handleDragStart}
      data-block-id={block.id}
      data-block-type={block.type}
    >
      {/* Block controls */}
      {!readonly && showControls && (
        <div className={`
          sparkblock-block-controls
          ${showBlockControls ? 'sparkblock-block-controls--visible' : ''}
        `}>
          <button
            className="sparkblock-control sparkblock-control--plus"
            onClick={handlePlusClick}
            title="Add block"
          >
            <Plus size={14} />
          </button>
          
          <button
            className="sparkblock-control sparkblock-control--drag"
            title="Drag to move"
          >
            <GripVertical size={14} />
          </button>
          
          <button
            className="sparkblock-control sparkblock-control--menu"
            onClick={handleMenuClick}
            title="Block options"
          >
            <MoreHorizontal size={14} />
          </button>
        </div>
      )}

      {/* Block content */}
      <div className="sparkblock-block-content">
        {getBlockRenderer()}
      </div>

      {/* Block regions (for container blocks) */}
      {block.regions && Object.entries(block.regions).map(([regionName, regionBlocks]) => (
        <div key={regionName} className={`sparkblock-region sparkblock-region--${regionName}`}>
          <div className="sparkblock-region-label">
            {regionName}
          </div>
          <div className="sparkblock-region-content">
            {regionBlocks.map((regionBlock) => (
              <BlockRenderer
                key={regionBlock.id}
                block={regionBlock}
                isSelected={false} // TODO: Check if region block is selected
                isFocused={false} // TODO: Check if region block is focused
                isDragging={false} // TODO: Check if region block is dragging
                nestingLevel={nestingLevel + 1}
                readonly={readonly}
                showControls={showControls}
                renderBlock={renderBlock}
              />
            ))}
            
            {/* Empty region placeholder */}
            {regionBlocks.length === 0 && !readonly && (
              <div 
                className="sparkblock-region-empty"
                onClick={() => engine.createBlock('paragraph', {
                  targetId: block.id,
                  position: 'inside',
                  regionName
                })}
              >
                Click to add content
              </div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}

// Helper function to check if block is empty
function isEmptyBlock(block: SparkBlock): boolean {
  const content = block.content;
  
  // Check common content fields
  if (content.text && String(content.text).trim()) return false;
  if (content.title && String(content.title).trim()) return false;
  if (content.content && String(content.content).trim()) return false;
  if (content.code && String(content.code).trim()) return false;
  
  return true;
}

================================================================================

File: components/BlockToolbar.tsx
// src/packages/sparkblock/components/BlockToolbar.tsx

import React from 'react';
import { Undo, Redo, Bold, Italic, Link } from 'lucide-react';
import type { SparkBlockEngine, SparkBlockEngineState, SparkBlockPlugin } from '../types';

export interface BlockToolbarProps {
  engine: SparkBlockEngine;
  state: SparkBlockEngineState;
  plugins: SparkBlockPlugin[];
}

export function BlockToolbar({ engine, state, plugins }: BlockToolbarProps) {
  const handleUndo = () => engine.undo();
  const handleRedo = () => engine.redo();

  return (
    <div className="sparkblock-toolbar">
      <div className="sparkblock-toolbar-section">
        <button
          className="sparkblock-toolbar-button"
          onClick={handleUndo}
          disabled={!state.canUndo}
          title="Undo"
        >
          <Undo size={16} />
        </button>
        
        <button
          className="sparkblock-toolbar-button"
          onClick={handleRedo}
          disabled={!state.canRedo}
          title="Redo"
        >
          <Redo size={16} />
        </button>
      </div>

      <div className="sparkblock-toolbar-section">
        <button className="sparkblock-toolbar-button" title="Bold">
          <Bold size={16} />
        </button>
        
        <button className="sparkblock-toolbar-button" title="Italic">
          <Italic size={16} />
        </button>
        
        <button className="sparkblock-toolbar-button" title="Link">
          <Link size={16} />
        </button>
      </div>

      {/* Plugin toolbars */}
      <div className="sparkblock-toolbar-plugins">
        {plugins.map(plugin => (
          <React.Fragment key={plugin.id}>
            {plugin.renderToolbar?.()}
          </React.Fragment>
        ))}
      </div>
    </div>
  );
}

================================================================================

File: components/PlusMenu.tsx
// src/packages/sparkblock/components/PlusMenu.tsx

import React, { useState, useEffect, useRef } from 'react';
import { Type, Heading1, Heading2, Heading3, Quote, Code, List, ListOrdered, Image, Minus, X } from 'lucide-react';
import { useSparkBlock } from './SparkBlockProvider';

export interface PlusMenuProps {
  position: { x: number; y: number };
  onClose: () => void;
}

interface BlockTypeOption {
  id: string;
  name: string;
  description: string;
  icon: React.ReactNode;
  category: string;
  keywords: string[];
}

const BLOCK_TYPES: BlockTypeOption[] = [
  {
    id: 'paragraph',
    name: 'Text',
    description: 'Plain text paragraph',
    icon: <Type size={16} />,
    category: 'Basic',
    keywords: ['text', 'paragraph', 'p']
  },
  {
    id: 'heading_1',
    name: 'Heading 1',
    description: 'Large heading',
    icon: <Heading1 size={16} />,
    category: 'Text',
    keywords: ['heading', 'h1', 'title']
  },
  {
    id: 'heading_2',
    name: 'Heading 2',
    description: 'Medium heading',
    icon: <Heading2 size={16} />,
    category: 'Text',
    keywords: ['heading', 'h2', 'subtitle']
  },
  {
    id: 'heading_3',
    name: 'Heading 3',
    description: 'Small heading',
    icon: <Heading3 size={16} />,
    category: 'Text',
    keywords: ['heading', 'h3']
  },
  {
    id: 'quote',
    name: 'Quote',
    description: 'Capture a quote',
    icon: <Quote size={16} />,
    category: 'Text',
    keywords: ['quote', 'blockquote', 'citation']
  },
  {
    id: 'code',
    name: 'Code',
    description: 'Code block with syntax highlighting',
    icon: <Code size={16} />,
    category: 'Text',
    keywords: ['code', 'programming', 'snippet']
  },
  {
    id: 'unordered_list',
    name: 'Bulleted List',
    description: 'Simple bulleted list',
    icon: <List size={16} />,
    category: 'Text',
    keywords: ['list', 'bullet', 'ul']
  },
  {
    id: 'ordered_list',
    name: 'Numbered List',
    description: 'List with numbers',
    icon: <ListOrdered size={16} />,
    category: 'Text',
    keywords: ['list', 'numbered', 'ol']
  },
  {
    id: 'image',
    name: 'Image',
    description: 'Upload or embed an image',
    icon: <Image size={16} />,
    category: 'Media',
    keywords: ['image', 'photo', 'picture']
  },
  {
    id: 'divider',
    name: 'Divider',
    description: 'Visual divider',
    icon: <Minus size={16} />,
    category: 'Layout',
    keywords: ['divider', 'separator', 'hr']
  }
];

export function PlusMenu({ position, onClose }: PlusMenuProps) {
  const { engine } = useSparkBlock();
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedIndex, setSelectedIndex] = useState(0);
  const menuRef = useRef<HTMLDivElement>(null);
  const searchRef = useRef<HTMLInputElement>(null);

  // Filter block types based on search
  const filteredTypes = BLOCK_TYPES.filter(type =>
    type.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
    type.description.toLowerCase().includes(searchQuery.toLowerCase()) ||
    type.keywords.some(keyword => keyword.toLowerCase().includes(searchQuery.toLowerCase()))
  );

  // Group by category
  const groupedTypes = filteredTypes.reduce((groups, type) => {
    if (!groups[type.category]) {
      groups[type.category] = [];
    }
    groups[type.category].push(type);
    return groups;
  }, {} as Record<string, BlockTypeOption[]>);

  // Handle block selection
  const handleSelectBlock = async (blockType: string) => {
    try {
      await engine.createBlock(blockType);
      onClose();
    } catch (error) {
      console.error('Failed to create block:', error);
    }
  };

  // Handle keyboard navigation
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      switch (event.key) {
        case 'ArrowDown':
          event.preventDefault();
          setSelectedIndex(prev => Math.min(prev + 1, filteredTypes.length - 1));
          break;
          
        case 'ArrowUp':
          event.preventDefault();
          setSelectedIndex(prev => Math.max(prev - 1, 0));
          break;
          
        case 'Enter':
          event.preventDefault();
          if (filteredTypes[selectedIndex]) {
            handleSelectBlock(filteredTypes[selectedIndex].id);
          }
          break;
          
        case 'Escape':
          onClose();
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [filteredTypes, selectedIndex, onClose]);

  // Handle click outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        onClose();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [onClose]);

  // Focus search input
  useEffect(() => {
    if (searchRef.current) {
      searchRef.current.focus();
    }
  }, []);

  // Reset selection when search changes
  useEffect(() => {
    setSelectedIndex(0);
  }, [searchQuery]);

  return (
    <div
      ref={menuRef}
      className="sparkblock-plus-menu"
      style={{
        position: 'fixed',
        left: position.x,
        top: position.y,
        zIndex: 1000
      }}
    >
      <div className="sparkblock-plus-menu-header">
        <input
          ref={searchRef}
          type="text"
          placeholder="Search blocks..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="sparkblock-plus-menu-search"
        />
        <button onClick={onClose} className="sparkblock-plus-menu-close">
          <X size={14} />
        </button>
      </div>

      <div className="sparkblock-plus-menu-content">
        {filteredTypes.length === 0 ? (
          <div className="sparkblock-plus-menu-empty">
            No blocks found for "{searchQuery}"
          </div>
        ) : (
          Object.entries(groupedTypes).map(([category, types]) => (
            <div key={category} className="sparkblock-plus-menu-category">
              <div className="sparkblock-plus-menu-category-title">
                {category}
              </div>
              {types.map((type, index) => {
                const globalIndex = filteredTypes.findIndex(t => t.id === type.id);
                const isSelected = globalIndex === selectedIndex;
                
                return (
                  <button
                    key={type.id}
                    className={`sparkblock-plus-menu-item ${isSelected ? 'sparkblock-plus-menu-item--selected' : ''}`}
                    onClick={() => handleSelectBlock(type.id)}
                    onMouseEnter={() => setSelectedIndex(globalIndex)}
                  >
                    <div className="sparkblock-plus-menu-item-icon">
                      {type.icon}
                    </div>
                    <div className="sparkblock-plus-menu-item-content">
                      <div className="sparkblock-plus-menu-item-name">
                        {type.name}
                      </div>
                      <div className="sparkblock-plus-menu-item-description">
                        {type.description}
                      </div>
                    </div>
                  </button>
                );
              })}
            </div>
          ))
        )}
      </div>
    </div>
  );
}

================================================================================

File: components/SparkBlockProvider.tsx
// src/packages/sparkblock/components/SparkBlockProvider.tsx

import React, { createContext, useContext, ReactNode } from 'react';
import type { SparkBlockEngine, SparkBlockTheme } from '../types';

interface SparkBlockContextValue {
  engine: SparkBlockEngine;
  theme?: SparkBlockTheme;
  readonly: boolean;
}

const SparkBlockContext = createContext<SparkBlockContextValue | null>(null);

export interface SparkBlockProviderProps {
  engine: SparkBlockEngine;
  theme?: SparkBlockTheme;
  readonly?: boolean;
  children: ReactNode;
}

export function SparkBlockProvider({
  engine,
  theme,
  readonly = false,
  children
}: SparkBlockProviderProps) {
  const value: SparkBlockContextValue = {
    engine,
    theme,
    readonly
  };

  return (
    <SparkBlockContext.Provider value={value}>
      <div className="sparkblock-provider" data-theme={theme?.name}>
        {children}
      </div>
    </SparkBlockContext.Provider>
  );
}

export function useSparkBlock(): SparkBlockContextValue {
  const context = useContext(SparkBlockContext);
  if (!context) {
    throw new Error('useSparkBlock must be used within a SparkBlockProvider');
  }
  return context;
}

================================================================================

File: components/blocks/DefaultBlockRenderers.tsx
// src/packages/sparkblock/components/blocks/DefaultBlockRenderers.tsx

import React, { useCallback, useRef, useEffect } from 'react';
import type { SparkBlock, RenderContext } from '../../types';

export interface BlockComponentProps {
  block: SparkBlock;
  context: RenderContext;
}

// Paragraph block
export function ParagraphBlock({ block, context }: BlockComponentProps) {
  const ref = useRef<HTMLDivElement>(null);
  const content = block.content as { text?: string };

  const handleInput = useCallback((event: React.FormEvent<HTMLDivElement>) => {
    if (context.readonly) return;
    
    const text = event.currentTarget.textContent || '';
    context.onChange?.(block.id, { text });
  }, [context, block.id]);

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    context.onKeyDown?.(block.id, event);
  }, [context, block.id]);

  const handleFocus = useCallback(() => {
    context.onFocus?.(block.id);
  }, [context, block.id]);

  // Auto-focus when focused
  useEffect(() => {
    if (context.isFocused && ref.current) {
      ref.current.focus();
      
      // Move cursor to end
      const selection = window.getSelection();
      if (selection) {
        selection.selectAllChildren(ref.current);
        selection.collapseToEnd();
      }
    }
  }, [context.isFocused]);

  return (
    <div
      ref={ref}
      contentEditable={!context.readonly}
      suppressContentEditableWarning
      className="sparkblock-paragraph"
      onInput={handleInput}
      onKeyDown={handleKeyDown}
      onFocus={handleFocus}
      data-placeholder={content.text ? undefined : "Type something..."}
    >
      {content.text || ''}
    </div>
  );
}

// Heading blocks
export function HeadingBlock({ block, context }: BlockComponentProps) {
  const ref = useRef<HTMLHeadingElement>(null);
  const content = block.content as { text?: string; level?: number };
  const level = content.level || 1;
  const HeadingTag = `h${Math.min(Math.max(level, 1), 6)}` as keyof React.JSX.IntrinsicElements;

  const handleInput = useCallback((event: React.FormEvent) => {
    if (context.readonly) return;
    
    const text = (event.target as HTMLElement).textContent || '';
    context.onChange?.(block.id, { text });
  }, [context, block.id]);

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    context.onKeyDown?.(block.id, event);
  }, [context, block.id]);

  const handleFocus = useCallback(() => {
    context.onFocus?.(block.id);
  }, [context, block.id]);

  useEffect(() => {
    if (context.isFocused && ref.current) {
      ref.current.focus();
      
      const selection = window.getSelection();
      if (selection) {
        selection.selectAllChildren(ref.current);
        selection.collapseToEnd();
      }
    }
  }, [context.isFocused]);

  return (
    <HeadingTag
      ref={ref}
      contentEditable={!context.readonly}
      suppressContentEditableWarning
      className={`sparkblock-heading sparkblock-heading--${level}`}
      onInput={handleInput}
      onKeyDown={handleKeyDown}
      onFocus={handleFocus}
      data-placeholder={content.text ? undefined : `Heading ${level}`}
    >
      {content.text || ''}
    </HeadingTag>
  );
}

// Quote block
export function QuoteBlock({ block, context }: BlockComponentProps) {
  const ref = useRef<HTMLDivElement>(null);
  const content = block.content as { text?: string; author?: string };

  const handleInput = useCallback((event: React.FormEvent<HTMLDivElement>) => {
    if (context.readonly) return;
    
    const text = event.currentTarget.textContent || '';
    context.onChange?.(block.id, { text });
  }, [context, block.id]);

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    context.onKeyDown?.(block.id, event);
  }, [context, block.id]);

  const handleFocus = useCallback(() => {
    context.onFocus?.(block.id);
  }, [context, block.id]);

  useEffect(() => {
    if (context.isFocused && ref.current) {
      ref.current.focus();
    }
  }, [context.isFocused]);

  return (
    <blockquote className="sparkblock-quote">
      <div
        ref={ref}
        contentEditable={!context.readonly}
        suppressContentEditableWarning
        className="sparkblock-quote-text"
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        onFocus={handleFocus}
        data-placeholder={content.text ? undefined : "Enter quote..."}
      >
        {content.text || ''}
      </div>
      {content.author && (
        <cite className="sparkblock-quote-author">
          — {content.author}
        </cite>
      )}
    </blockquote>
  );
}

// Code block
export function CodeBlock({ block, context }: BlockComponentProps) {
  const ref = useRef<HTMLPreElement>(null);
  const content = block.content as { code?: string; language?: string };

  const handleInput = useCallback((event: React.FormEvent<HTMLPreElement>) => {
    if (context.readonly) return;
    
    const code = event.currentTarget.textContent || '';
    context.onChange?.(block.id, { code });
  }, [context, block.id]);

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    // Handle tab key for indentation
    if (event.key === 'Tab') {
      event.preventDefault();
      // Insert two spaces for indentation
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const textNode = document.createTextNode('  ');
        range.insertNode(textNode);
        range.setStartAfter(textNode);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }
      return;
    }
    
    context.onKeyDown?.(block.id, event);
  }, [context, block.id]);

  const handleFocus = useCallback(() => {
    context.onFocus?.(block.id);
  }, [context, block.id]);

  useEffect(() => {
    if (context.isFocused && ref.current) {
      ref.current.focus();
    }
  }, [context.isFocused]);

  return (
    <div className="sparkblock-code-block">
      {content.language && (
        <div className="sparkblock-code-language">
          {content.language}
        </div>
      )}
      <pre
        ref={ref}
        contentEditable={!context.readonly}
        suppressContentEditableWarning
        className="sparkblock-code"
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        onFocus={handleFocus}
        data-placeholder={content.code ? undefined : "Enter code..."}
      >
        {content.code || ''}
      </pre>
    </div>
  );
}

// List blocks
export function ListBlock({ block, context }: BlockComponentProps) {
  const ref = useRef<HTMLDivElement>(null);
  const content = block.content as { text?: string; ordered?: boolean };
  const isOrdered = content.ordered || false;

  const handleInput = useCallback((event: React.FormEvent<HTMLDivElement>) => {
    if (context.readonly) return;
    
    const text = event.currentTarget.textContent || '';
    context.onChange?.(block.id, { text });
  }, [context, block.id]);

  const handleKeyDown = useCallback((event: React.KeyboardEvent) => {
    context.onKeyDown?.(block.id, event);
  }, [context, block.id]);

  const handleFocus = useCallback(() => {
    context.onFocus?.(block.id);
  }, [context, block.id]);

  useEffect(() => {
    if (context.isFocused && ref.current) {
      ref.current.focus();
    }
  }, [context.isFocused]);

  return (
    <div className={`sparkblock-list ${isOrdered ? 'sparkblock-list--ordered' : 'sparkblock-list--unordered'}`}>
      <div className="sparkblock-list-marker">
        {isOrdered ? '1.' : '•'}
      </div>
      <div
        ref={ref}
        contentEditable={!context.readonly}
        suppressContentEditableWarning
        className="sparkblock-list-content"
        onInput={handleInput}
        onKeyDown={handleKeyDown}
        onFocus={handleFocus}
        data-placeholder={content.text ? undefined : "List item..."}
      >
        {content.text || ''}
      </div>
    </div>
  );
}

// Image block
export function ImageBlock({ block, context }: BlockComponentProps) {
  const content = block.content as { 
    src?: string; 
    alt?: string; 
    caption?: string;
    width?: number;
    height?: number;
  };

  const handleCaptionChange = useCallback((event: React.FormEvent<HTMLDivElement>) => {
    if (context.readonly) return;
    
    const caption = event.currentTarget.textContent || '';
    context.onChange?.(block.id, { caption });
  }, [context, block.id]);

  if (!content.src) {
    return (
      <div className="sparkblock-image sparkblock-image--empty">
        <div className="sparkblock-image-placeholder">
          📷 Click to add image
        </div>
      </div>
    );
  }

  return (
    <div className="sparkblock-image">
      <img
        src={content.src}
        alt={content.alt || ''}
        className="sparkblock-image-element"
        style={{
          width: content.width ? `${content.width}px` : undefined,
          height: content.height ? `${content.height}px` : undefined
        }}
      />
      {(content.caption || !context.readonly) && (
        <div
          contentEditable={!context.readonly}
          suppressContentEditableWarning
          className="sparkblock-image-caption"
          onInput={handleCaptionChange}
          data-placeholder={content.caption ? undefined : "Add a caption..."}
        >
          {content.caption || ''}
        </div>
      )}
    </div>
  );
}

// Divider block
export function DividerBlock(): React.JSX.Element {
  return (
    <div className="sparkblock-divider">
      <hr />
    </div>
  );
}

// Unknown block fallback
export function UnknownBlock({ block, context }: BlockComponentProps) {
  return (
    <div className="sparkblock-unknown">
      <div className="sparkblock-unknown-header">
        <span className="sparkblock-unknown-type">Unknown block: {block.type}</span>
      </div>
      <div className="sparkblock-unknown-content">
        <pre>{JSON.stringify(block.content, null, 2)}</pre>
      </div>
    </div>
  );
}

// Export map of default renderers
export const DefaultBlockRenderers: Record<string, React.ComponentType<BlockComponentProps>> = {
  // Core text blocks
  'paragraph': ParagraphBlock,
  'heading': HeadingBlock,
  'heading_1': (props) => <HeadingBlock {...props} block={{...props.block, content: {...props.block.content, level: 1}}} />,
  'heading_2': (props) => <HeadingBlock {...props} block={{...props.block, content: {...props.block.content, level: 2}}} />,
  'heading_3': (props) => <HeadingBlock {...props} block={{...props.block, content: {...props.block.content, level: 3}}} />,
  'heading_4': (props) => <HeadingBlock {...props} block={{...props.block, content: {...props.block.content, level: 4}}} />,
  'heading_5': (props) => <HeadingBlock {...props} block={{...props.block, content: {...props.block.content, level: 5}}} />,
  'heading_6': (props) => <HeadingBlock {...props} block={{...props.block, content: {...props.block.content, level: 6}}} />,
  
  // Text formatting
  'quote': QuoteBlock,
  'code': CodeBlock,
  
  // Lists
  'list': ListBlock,
  'unordered_list': (props) => <ListBlock {...props} block={{...props.block, content: {...props.block.content, ordered: false}}} />,
  'ordered_list': (props) => <ListBlock {...props} block={{...props.block, content: {...props.block.content, ordered: true}}} />,
  
  // Media
  'image': ImageBlock,
  
  // Layout
  'divider': DividerBlock,
  
  // Fallback
  'unknown': UnknownBlock
};

================================================================================

File: engine/SparkBlockEngine.ts
// src/packages/sparkblock/engine/SparkBlockEngine.ts

// import { nanoid } from 'nanoid'; // Removed unused import
import type {
  SparkBlock,
  SparkBlockAdapter,
  SparkBlockEngine,
  SparkBlockEngineOptions,
  SparkBlockEngineState,
  SparkBlockPlugin,
  SparkBlockCommand,
  SparkBlockEvent,
  SparkBlockEventListener,
  InsertPosition,
  MoveOperation,
  UpdateOperation,
  ValidationResult
} from '../types';
import { SparkBlockError } from '../errors';
import { BlockOperations } from '../utils/blockOperations';

export class SparkBlockEngineImpl implements SparkBlockEngine {
  private adapter: SparkBlockAdapter;
  private plugins: Map<string, SparkBlockPlugin> = new Map();
  private commands: Map<string, SparkBlockCommand> = new Map();
  private eventListeners: Map<string, Set<SparkBlockEventListener>> = new Map();
  private stateListeners: Set<(state: SparkBlockEngineState) => void> = new Set();
  
  private state: SparkBlockEngineState = {
    blocks: [],
    selectedBlockIds: [],
    focusedBlockId: null,
    isDirty: false,
    isLoading: false,
    isSaving: false,
    canUndo: false,
    canRedo: false,
    showPlusMenu: false,
    showBlockMenu: false,
    dragState: {
      isDragging: false
    }
  };

  // History management
  private history: SparkBlock[][] = [];
  private historyIndex: number = -1;
  private readonly maxHistorySteps: number;

  // Auto-save
  private autoSaveTimer?: NodeJS.Timeout;
  private readonly autoSave: boolean;
  private readonly autoSaveDelay: number;

  constructor(options: SparkBlockEngineOptions) {
    this.adapter = options.adapter;
    this.autoSave = options.autoSave ?? true;
    this.autoSaveDelay = options.autoSaveDelay ?? 1000;
    this.maxHistorySteps = options.maxUndoSteps ?? 50;

    // Initialize built-in commands
    this.initializeBuiltInCommands();

    // Load plugins
    if (options.plugins) {
      options.plugins.forEach(plugin => this.addPlugin(plugin));
    }
  }

  // === STATE MANAGEMENT ===

  getState(): SparkBlockEngineState {
    return { ...this.state };
  }

  subscribe(listener: (state: SparkBlockEngineState) => void): () => void {
    this.stateListeners.add(listener);
    return () => this.stateListeners.delete(listener);
  }

  setState(updates: Partial<SparkBlockEngineState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyStateListeners();
  }

  private setStatePrivate(updates: Partial<SparkBlockEngineState>): void {
    this.setState(updates);
  }

  private notifyStateListeners(): void {
    const state = this.getState();
    this.stateListeners.forEach(listener => listener(state));
  }

  // === DOCUMENT LIFECYCLE ===

  async loadDocument<TDocument>(document: TDocument): Promise<void> {
    this.setStatePrivate({ isLoading: true });
    
    try {
      // Parse document through adapter
      let blocks = await this.adapter.parse(document);
      
      // Apply plugin transformations
      for (const plugin of this.plugins.values()) {
        if (plugin.onDocumentLoad) {
          blocks = await plugin.onDocumentLoad(blocks);
        }
      }

      // Update state
      this.setStatePrivate({
        blocks,
        isDirty: false,
        isLoading: false,
        selectedBlockIds: [],
        focusedBlockId: null
      });

      // Reset history
      this.history = [this.deepClone(blocks)];
      this.historyIndex = 0;
      this.updateHistoryState();

      this.emit('document:loaded', { blocks });
    } catch (error) {
      this.setStatePrivate({ isLoading: false });
      throw new SparkBlockError(
        `Failed to load document: ${(error as Error).message}`
      );
    }
  }

  async saveDocument<TDocument>(): Promise<TDocument> {
    this.setStatePrivate({ isSaving: true });
    
    try {
      let blocks = [...this.state.blocks];
      
      // Apply plugin transformations
      for (const plugin of this.plugins.values()) {
        if (plugin.onDocumentSave) {
          blocks = await plugin.onDocumentSave(blocks);
        }
      }

      // Serialize through adapter
      const document = await this.adapter.serialize(blocks);
      
      this.setStatePrivate({
        isDirty: false,
        isSaving: false
      });

      this.emit('document:saved', { document });
      return document as TDocument;
    } catch (error) {
      this.setStatePrivate({ isSaving: false });
      throw new SparkBlockError(
        `Failed to save document: ${(error as Error).message}`
      );
    }
  }

  // === BLOCK OPERATIONS ===

  async createBlock(
    type: string,
    position?: InsertPosition,
    initialData?: Record<string, unknown>
  ): Promise<void> {
    const block = await this.adapter.createBlock(type, initialData);
    
    // Apply plugin transformations
    for (const plugin of this.plugins.values()) {
      if (plugin.onBlockCreate) {
        const transformed = await plugin.onBlockCreate(block);
        Object.assign(block, transformed);
      }
    }

    const newBlocks = BlockOperations.insertBlock(this.state.blocks, block, position);
    this.updateBlocks(newBlocks);
    
    // Focus the new block
    this.focusBlock(block.id);
    
    this.emit('block:created', { block, position });
  }

  async updateBlock(blockId: string, updates: UpdateOperation): Promise<void> {
    const oldBlock = this.getBlock(blockId);
    if (!oldBlock) {
      throw new SparkBlockError(`Block ${blockId} not found`);
    }

    const newBlocks = BlockOperations.updateBlock(this.state.blocks, blockId, updates);
    const newBlock = BlockOperations.findBlock(newBlocks, blockId)?.block;
    
    if (newBlock) {
      // Apply plugin transformations
      for (const plugin of this.plugins.values()) {
        if (plugin.onBlockUpdate) {
          const transformed = await plugin.onBlockUpdate(newBlock, oldBlock);
          Object.assign(newBlock, transformed);
        }
      }
    }

    this.updateBlocks(newBlocks);
    this.emit('block:updated', { blockId, updates, oldBlock, newBlock });
  }

  async deleteBlock(blockId: string): Promise<void> {
    const block = this.getBlock(blockId);
    if (!block) {
      throw new SparkBlockError(`Block ${blockId} not found`);
    }

    // Apply plugin hooks
    for (const plugin of this.plugins.values()) {
      if (plugin.onBlockDelete) {
        await plugin.onBlockDelete(block);
      }
    }

    const newBlocks = BlockOperations.removeBlock(this.state.blocks, blockId);
    this.updateBlocks(newBlocks);
    
    // Update selection
    this.deselectBlock(blockId);
    if (this.state.focusedBlockId === blockId) {
      this.blurBlock();
    }

    this.emit('block:deleted', { block });
  }

  async moveBlock(operation: MoveOperation): Promise<void> {
    const block = this.getBlock(operation.blockId);
    if (!block) {
      throw new SparkBlockError(`Block ${operation.blockId} not found`);
    }

    // Apply plugin hooks
    for (const plugin of this.plugins.values()) {
      if (plugin.onBlockMove) {
        await plugin.onBlockMove(block, operation);
      }
    }

    const newBlocks = BlockOperations.moveBlock(this.state.blocks, operation);
    this.updateBlocks(newBlocks);
    
    this.emit('block:moved', { block, operation });
  }

  async duplicateBlock(blockId: string, position?: InsertPosition): Promise<void> {
    const newBlocks = BlockOperations.duplicateBlock(this.state.blocks, blockId, position);
    this.updateBlocks(newBlocks);
    
    this.emit('block:duplicated', { originalBlockId: blockId, position });
  }

  // === BLOCK QUERIES ===

  getBlock(blockId: string): SparkBlock | null {
    const location = BlockOperations.findBlock(this.state.blocks, blockId);
    return location?.block || null;
  }

  getBlocks(): SparkBlock[] {
    return [...this.state.blocks];
  }

  getSelectedBlocks(): SparkBlock[] {
    return this.state.selectedBlockIds
      .map(id => this.getBlock(id))
      .filter((block): block is SparkBlock => block !== null);
  }

  getFocusedBlock(): SparkBlock | null {
    return this.state.focusedBlockId ? this.getBlock(this.state.focusedBlockId) : null;
  }

  // === SELECTION MANAGEMENT ===

  selectBlock(blockId: string, addToSelection: boolean = false): void {
    if (!this.getBlock(blockId)) return;

    const selectedIds = addToSelection 
      ? [...this.state.selectedBlockIds, blockId]
      : [blockId];
    
    this.setStatePrivate({
      selectedBlockIds: [...new Set(selectedIds)] // Remove duplicates
    });

    this.emit('selection:changed', { selectedBlockIds: this.state.selectedBlockIds });
  }

  deselectBlock(blockId: string): void {
    const selectedIds = this.state.selectedBlockIds.filter(id => id !== blockId);
    this.setStatePrivate({ selectedBlockIds: selectedIds });
    
    this.emit('selection:changed', { selectedBlockIds: this.state.selectedBlockIds });
  }

  clearSelection(): void {
    this.setStatePrivate({ selectedBlockIds: [] });
    this.emit('selection:changed', { selectedBlockIds: [] });
  }

  focusBlock(blockId: string): void {
    if (!this.getBlock(blockId)) return;

    this.setStatePrivate({ focusedBlockId: blockId });
    this.emit('focus:changed', { focusedBlockId: blockId });
  }

  blurBlock(): void {
    this.setStatePrivate({ focusedBlockId: null });
    this.emit('focus:changed', { focusedBlockId: null });
  }

  // === HISTORY ===

  async undo(): Promise<void> {
    if (!this.state.canUndo) return;

    this.historyIndex--;
    const blocks = this.deepClone(this.history[this.historyIndex]);
    
    this.setStatePrivate({ blocks });
    this.updateHistoryState();
    
    this.emit('history:undo', { blocks });
  }

  async redo(): Promise<void> {
    if (!this.state.canRedo) return;

    this.historyIndex++;
    const blocks = this.deepClone(this.history[this.historyIndex]);
    
    this.setStatePrivate({ blocks });
    this.updateHistoryState();
    
    this.emit('history:redo', { blocks });
  }

  // === COMMANDS ===

  async executeCommand(command: string, ...args: unknown[]): Promise<void> {
    const cmd = this.commands.get(command);
    if (!cmd) {
      throw new SparkBlockError(`Command "${command}" not found`);
    }

    if (cmd.canExecute && !cmd.canExecute(this)) {
      throw new SparkBlockError(`Command "${command}" cannot be executed`);
    }

    await cmd.execute(this, ...args);
    this.emit('command:executed', { command, args });
  }

  registerCommand(name: string, command: SparkBlockCommand): void {
    this.commands.set(name, command);
  }

  // === EVENTS ===

  emit<TData>(type: string, data: TData, blockId?: string): void {
    const event: SparkBlockEvent<TData> = {
      type,
      data,
      timestamp: Date.now(),
      blockId
    };

    const listeners = this.eventListeners.get(type);
    if (listeners) {
      listeners.forEach(listener => listener(event));
    }
  }

  on<TData>(type: string, listener: SparkBlockEventListener<TData>): () => void {
    if (!this.eventListeners.has(type)) {
      this.eventListeners.set(type, new Set());
    }
    
    this.eventListeners.get(type)!.add(listener as SparkBlockEventListener);
    
    return () => {
      const listeners = this.eventListeners.get(type);
      if (listeners) {
        listeners.delete(listener as SparkBlockEventListener);
      }
    };
  }

  // === PLUGINS ===

  async addPlugin(plugin: SparkBlockPlugin): Promise<void> {
    this.plugins.set(plugin.id, plugin);
    
    // Register plugin commands
    if (plugin.commands) {
      for (const [name, command] of Object.entries(plugin.commands)) {
        this.registerCommand(name, command);
      }
    }
    
    // Register plugin shortcuts
    if (plugin.shortcuts) {
      for (const [shortcut, command] of Object.entries(plugin.shortcuts)) {
        this.registerCommand(`shortcut:${shortcut}`, command);
      }
    }

    // Call plugin mount hook
    if (plugin.onEditorMount) {
      await plugin.onEditorMount(this);
    }

    this.emit('plugin:added', { plugin });
  }

  async removePlugin(pluginId: string): Promise<void> {
    const plugin = this.plugins.get(pluginId);
    if (!plugin) return;

    // Call plugin unmount hook
    if (plugin.onEditorUnmount) {
      await plugin.onEditorUnmount(this);
    }

    // Remove plugin commands
    if (plugin.commands) {
      for (const name of Object.keys(plugin.commands)) {
        this.commands.delete(name);
      }
    }

    // Remove plugin shortcuts
    if (plugin.shortcuts) {
      for (const shortcut of Object.keys(plugin.shortcuts)) {
        this.commands.delete(`shortcut:${shortcut}`);
      }
    }

    this.plugins.delete(pluginId);
    this.emit('plugin:removed', { pluginId });
  }

  getPlugin(pluginId: string): SparkBlockPlugin | null {
    return this.plugins.get(pluginId) || null;
  }

  // === VALIDATION ===

  async validateBlock(blockId: string): Promise<ValidationResult> {
    const block = this.getBlock(blockId);
    if (!block) {
      return {
        valid: false,
        errors: [{ message: `Block ${blockId} not found` }]
      };
    }

    return await this.adapter.validateBlock(block);
  }

  async validateDocument(): Promise<ValidationResult> {
    const results = await Promise.all(
      this.state.blocks.map(block => this.validateBlock(block.id))
    );

    const allErrors = results.flatMap(result => result.errors);
    const allWarnings = results.flatMap(result => result.warnings || []);

    return {
      valid: allErrors.length === 0,
      errors: allErrors,
      warnings: allWarnings
    };
  }

  // === UTILITY ===

  destroy(): void {
    // Clear auto-save timer
    if (this.autoSaveTimer) {
      clearTimeout(this.autoSaveTimer);
    }

    // Unmount all plugins
    this.plugins.forEach(async (plugin) => {
      if (plugin.onEditorUnmount) {
        await plugin.onEditorUnmount(this);
      }
    });

    // Clear all listeners
    this.stateListeners.clear();
    this.eventListeners.clear();
    
    this.emit('engine:destroyed', {});
  }

  // === PRIVATE METHODS ===

  private updateBlocks(newBlocks: SparkBlock[]): void {
    this.setStatePrivate({
      blocks: newBlocks,
      isDirty: true
    });

    // Add to history
    this.addToHistory(newBlocks);
    
    // Auto-save
    this.scheduleAutoSave();
  }

  private addToHistory(blocks: SparkBlock[]): void {
    // Remove any future history if we're not at the end
    if (this.historyIndex < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyIndex + 1);
    }

    // Add new state
    this.history.push(this.deepClone(blocks));
    
    // Limit history size
    if (this.history.length > this.maxHistorySteps) {
      this.history.shift();
    } else {
      this.historyIndex++;
    }

    this.updateHistoryState();
  }

  private updateHistoryState(): void {
    this.setStatePrivate({
      canUndo: this.historyIndex > 0,
      canRedo: this.historyIndex < this.history.length - 1
    });
  }

  private scheduleAutoSave(): void {
    if (!this.autoSave) return;

    if (this.autoSaveTimer) {
      clearTimeout(this.autoSaveTimer);
    }

    this.autoSaveTimer = setTimeout(async () => {
      if (this.state.isDirty) {
        try {
          await this.saveDocument();
        } catch (error) {
          this.emit('autosave:failed', { error });
        }
      }
    }, this.autoSaveDelay);
  }

  private initializeBuiltInCommands(): void {
    // Block creation commands
    this.registerCommand('create-paragraph', {
      name: 'Create Paragraph',
      execute: async (engine) => {
        await engine.createBlock('paragraph');
      }
    });

    this.registerCommand('create-heading', {
      name: 'Create Heading',
      execute: async (engine, ...args: unknown[]) => {
        const level = (args[0] as number) || 1;
        await engine.createBlock(`heading_${level}`);
      }
    });

    // Navigation commands
    this.registerCommand('select-all', {
      name: 'Select All',
      execute: (engine) => {
        const allIds = BlockOperations.getAllBlockIds(engine.getBlocks());
        (engine as SparkBlockEngineImpl).setStatePrivate({ selectedBlockIds: allIds });
      }
    });

    this.registerCommand('delete-selected', {
      name: 'Delete Selected',
      execute: async (engine) => {
        const selectedIds = [...engine.getState().selectedBlockIds];
        for (const id of selectedIds) {
          await engine.deleteBlock(id);
        }
      },
      canExecute: (engine) => engine.getState().selectedBlockIds.length > 0
    });
  }

  private deepClone<T>(obj: T): T {
    return JSON.parse(JSON.stringify(obj));
  }
}

// Factory function
export function createSparkBlockEngine(options: SparkBlockEngineOptions): SparkBlockEngine {
  return new SparkBlockEngineImpl(options);
}

================================================================================

